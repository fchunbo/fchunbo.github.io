<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fchunbo 博客</title>
  
  <subtitle>不要在最努力的年龄选择了安逸！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fchunbo.github.io/"/>
  <updated>2019-09-03T15:03:37.000Z</updated>
  <id>https://fchunbo.github.io/</id>
  
  <author>
    <name>范春波</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go Module的简单使用</title>
    <link href="https://fchunbo.github.io/2019/08/12/Go/go%20module/1.%20%E5%A6%82%E4%BD%95%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8go%20mod%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>https://fchunbo.github.io/2019/08/12/Go/go module/1. 如何简单的使用go mod来进行包管理/</id>
    <published>2019-08-11T16:00:00.000Z</published>
    <updated>2019-09-03T15:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go-Module的简单使用"><a href="#Go-Module的简单使用" class="headerlink" title="Go Module的简单使用"></a>Go Module的简单使用</h1><h3 id="1-打开Go-Module"><a href="#1-打开Go-Module" class="headerlink" title="1. 打开Go Module"></a>1. 打开Go Module</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GO111MODULE=on[off|auto]</span><br></pre></td></tr></table></figure><ul><li>on 表示仅使用Go Modules模式来管理go的依赖</li><li>off 表示关闭Go Modules模式，使用GOPATH</li><li>auto 表示如果在GOPATH下，就使用GOPATH；同时也可以使用GO Modules模式</li></ul><h3 id="2-设置代理"><a href="#2-设置代理" class="headerlink" title="2. 设置代理"></a>2. 设置代理</h3><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOPROXY=https://goproxy.io</span><br></pre></td></tr></table></figure><p>这样设置之后，可以下载google相关的包。</p><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h3><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init 模块名</span><br></pre></td></tr></table></figure><p>使用上述命令，就可以初始化一个模块。</p>]]></content>
    
    <summary type="html">
    
      Go Module的简单使用
1. 打开Go Module
1


export GO111MODULE=on[off|auto]


 * on 表示仅使用Go Modules模式来管理go的依赖
 * off 表示关闭Go Modules模式，使用GOPATH
 * auto 表示如果在GOPA
    
    </summary>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>1. Go 错误处理</title>
    <link href="https://fchunbo.github.io/2019/08/12/Go/1.%20go_%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>https://fchunbo.github.io/2019/08/12/Go/1. go_错误处理/</id>
    <published>2019-08-11T16:00:00.000Z</published>
    <updated>2019-09-03T15:14:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-错误的处理"><a href="#1-错误的处理" class="headerlink" title="1. 错误的处理"></a>1. 错误的处理</h1><p>Go 程序使用 <code>error</code> 值来表示错误状态。</p><p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> error <span class="hljs-keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="hljs-keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（与 <code>fmt.Stringer</code> 类似，<code>fmt</code> 包在输出时也会试图匹配 <code>error</code>。）</p><p>通常函数会返回一个 <code>error</code> 值，调用的它的代码应当判断这个错误是否等于 <code>nil</code>， 来进行错误处理。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i, err := strconv.Atoi(<span class="hljs-string">"42"</span>)</span><br><span class="line"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="hljs-string">"couldn't convert number: %v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="hljs-string">"Converted integer:"</span>, i)</span><br></pre></td></tr></table></figure><p><code>error</code> 为 nil 时表示成功；非 nil 的 <code>error</code> 表示错误</p><p><strong>注意：上述简介说明了，接口类型的变量，零值为nil。这里说了，一般处理错误的方式为，判断返回的err是否为nil，如果err不为nil，表示有错误发生，否则表示没有错误</strong></p><p>例子：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * @Author fchunbo</span></span><br><span class="line"><span class="hljs-comment"> * @Date 2018/12/3 上午11:07</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line">    <span class="hljs-string">"fmt"</span></span><br><span class="line">    <span class="hljs-string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 定义结构体</span></span><br><span class="line"><span class="hljs-keyword">type</span> Myerror <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    When time.Time <span class="hljs-comment">// 定义结构体时不需要逗号</span></span><br><span class="line">    What <span class="hljs-keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 实现Error方法， 隐藏接口为： fmt包中的error接口</span></span><br><span class="line"><span class="hljs-comment">// 此时 *Myerror类型，就实现了error接口，实质</span></span><br><span class="line"><span class="hljs-comment">// 就是为error方法设置方法的接收者。</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Myerror)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"at %v， %s"</span>, e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &amp;Myerror&#123;</span><br><span class="line">        time.Now(),</span><br><span class="line">        <span class="hljs-string">"It didn't work"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 和fmt.Stringer接口类似，fmt输出时会去匹配error接口的Error方法。</span></span><br><span class="line"><span class="hljs-comment">// 也就是说，当类型实现了error接口的Error方法时，在输出时会自动</span></span><br><span class="line"><span class="hljs-comment">// 调用类型的Error方法，输出Error方法返回的值。</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> err := run(); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err) <span class="hljs-comment">// fmt中的打印函数，会自动匹配Error方法和String()方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      1. 错误的处理
Go 程序使用 error 值来表示错误状态。

与 fmt.Stringer 类似，error 类型是一个内建接口：

1
2
3


type error interface {
    Error() string
}


（与 fmt.Stringer 类似，fmt 包在输
    
    </summary>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>4. Go 可导出概念的理解</title>
    <link href="https://fchunbo.github.io/2019/08/12/Go/4.%20Go%E4%B8%AD%E5%8F%AF%E5%AF%BC%E5%87%BA%E7%9A%84%E6%A6%82%E5%BF%B5%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://fchunbo.github.io/2019/08/12/Go/4. Go中可导出的概念的理解/</id>
    <published>2019-08-11T16:00:00.000Z</published>
    <updated>2019-09-03T15:14:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用的Go的过程中，发现引入包后，使用其结构体时，不能访问结构体中以小写字母开头的变量。总之在Go中，以首字母的大小写来控制变量或函数的访问。首字母大写，称为可导出，相当于Java中的public关键字；而首字母小写，称之为不可导出，相当于Java中的private/protected.</p>]]></content>
    
    <summary type="html">
    
      在使用的Go的过程中，发现引入包后，使用其结构体时，不能访问结构体中以小写字母开头的变量。总之在Go中，以首字母的大小写来控制变量或函数的访问。首字母大写，称为可导出，相当于Java中的public关键字；而首字母小写，称之为不可导出，相当于Java中的private/protected.
    
    </summary>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 执行流程</title>
    <link href="https://fchunbo.github.io/2019/08/02/mysql/01-mysql%E5%9F%BA%E7%A1%80/2.%20mysql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://fchunbo.github.io/2019/08/02/mysql/01-mysql基础/2. mysql执行流程/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-09-03T23:34:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简单版本的执行流程"><a href="#1-简单版本的执行流程" class="headerlink" title="1. 简单版本的执行流程"></a>1. 简单版本的执行流程</h2><p><img src="/images/mysql/simple_execution_flow.png" alt=""></p><h2 id="2-复杂版本的执行流程"><a href="#2-复杂版本的执行流程" class="headerlink" title="2. 复杂版本的执行流程"></a>2. 复杂版本的执行流程</h2><p><img src="/images/mysql/complex_execution_flow.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      1. 简单版本的执行流程


2. 复杂版本的执行流程
    
    </summary>
    
    
      <category term="MySql" scheme="https://fchunbo.github.io/categories/MySql/"/>
    
      <category term="Basic" scheme="https://fchunbo.github.io/categories/MySql/Basic/"/>
    
    
      <category term="MySql" scheme="https://fchunbo.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql中的索引原理</title>
    <link href="https://fchunbo.github.io/2019/08/02/mysql/01-mysql%E5%9F%BA%E7%A1%80/6.%20mysql%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <id>https://fchunbo.github.io/2019/08/02/mysql/01-mysql基础/6. mysql中的索引/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-09-03T23:37:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1. 是什么"></a>1. 是什么</h2><p>官方介绍索引是帮助MySQL<strong>高效获取数据</strong>的<strong>数据结构</strong>。更通俗的说，数据库索引好比是一本书前面的目录，能<strong>加快数据库的查询速度</strong>， 也就是<strong>排序好的快速查询的数据结构</strong>。</p><h2 id="2-索引的优势和劣势"><a href="#2-索引的优势和劣势" class="headerlink" title="2. 索引的优势和劣势"></a>2. 索引的优势和劣势</h2><h3 id="2-1-优势"><a href="#2-1-优势" class="headerlink" title="2.1 优势"></a>2.1 优势</h3><ul><li><p>可以提高数据<strong>检索的效率</strong>，<strong>降低数据库的IO成本</strong>，类似于书的目录。 – <strong>检索</strong></p></li><li><p>通过<strong>索引列对数据进行排序</strong>，降低数据排序的成本，降低了CPU的消耗。 –<strong>排序</strong></p></li><li><p>被索引的列会自动进行排序，包括【单列索引】和【组合索引】，只是<strong>组合索引</strong>的排序要复杂一  些。</p></li><li><p>如果按照索引列的顺序进行排序，对应order by语句来说，效率就会提高很多。</p></li><li>where 索引列 在存储引擎层 处理</li></ul><h3 id="2-2-劣势"><a href="#2-2-劣势" class="headerlink" title="2.2 劣势"></a>2.2 劣势</h3><ul><li><p>索引会占据磁盘空间</p></li><li><p>索引虽然会提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件。</p></li></ul><h2 id="3-索引的分类"><a href="#3-索引的分类" class="headerlink" title="3. 索引的分类"></a>3. 索引的分类</h2><ul><li><p>单列索引</p></li><li><p>组合索引</p></li><li>全文索引</li><li><p>空间索引</p></li><li><p>位图索引  oracle</p></li></ul><h2 id="4-索引的使用"><a href="#4-索引的使用" class="headerlink" title="4. 索引的使用"></a>4. 索引的使用</h2><h3 id="4-1-创建索引"><a href="#4-1-创建索引" class="headerlink" title="4.1 创建索引"></a>4.1 创建索引</h3><ul><li>单列索引之普通索引</li></ul><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> index_name <span class="hljs-keyword">ON</span> <span class="hljs-keyword">table</span>(<span class="hljs-keyword">column</span>(<span class="hljs-keyword">length</span>)) ;</span><br><span class="line"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> index_name (<span class="hljs-keyword">column</span>(<span class="hljs-keyword">length</span>)) ;</span><br></pre></td></tr></table></figure><ul><li><p>单列索引之唯一索引</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">INDEX</span> index_name <span class="hljs-keyword">ON</span> <span class="hljs-keyword">table</span>(<span class="hljs-keyword">column</span>(<span class="hljs-keyword">length</span>)) ;</span><br><span class="line"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name <span class="hljs-keyword">add</span> <span class="hljs-keyword">unique</span> <span class="hljs-keyword">index</span> index_name(<span class="hljs-keyword">column</span>);</span><br></pre></td></tr></table></figure></li><li><p>单列索引之全文索引</p></li></ul><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> FULLTEXT <span class="hljs-keyword">INDEX</span> index_name <span class="hljs-keyword">ON</span> <span class="hljs-keyword">table</span>(<span class="hljs-keyword">column</span>(<span class="hljs-keyword">length</span>)) ; </span><br><span class="line"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name <span class="hljs-keyword">add</span> fulltext index_name(<span class="hljs-keyword">column</span>)</span><br></pre></td></tr></table></figure><ul><li>组合索引 </li></ul><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> article <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> index_titme_time (title(<span class="hljs-number">50</span>),<span class="hljs-keyword">time</span>(<span class="hljs-number">10</span>)) ;</span><br></pre></td></tr></table></figure><h3 id="4-2-删除索引"><a href="#4-2-删除索引" class="headerlink" title="4.2 删除索引"></a>4.2 删除索引</h3><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> index_name <span class="hljs-keyword">ON</span> <span class="hljs-keyword">table</span></span><br></pre></td></tr></table></figure><h3 id="4-3查看索引"><a href="#4-3查看索引" class="headerlink" title="4.3查看索引"></a>4.3查看索引</h3><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><h2 id="5-索引原理分析"><a href="#5-索引原理分析" class="headerlink" title="5. 索引原理分析"></a>5. 索引原理分析</h2><h3 id="5-1-索引的存储结构"><a href="#5-1-索引的存储结构" class="headerlink" title="5.1 索引的存储结构"></a>5.1 索引的存储结构</h3><p>索引是在<strong>存储引擎</strong>中实现的，也就是说不同的存储引擎，会使用不同的索引；</p><p>MyIsam和InnoDB存储引擎： 只支持<strong>B+Tree索引</strong>，也就是说默认使用<strong>B+Tree</strong>索引，不能够更换</p><p>Memory/HEAP存储引擎： 支持<strong>HASH和BTree</strong>索引</p><h3 id="5-2-B树和B-树"><a href="#5-2-B树和B-树" class="headerlink" title="5.2 B树和B+树"></a>5.2 B树和B+树</h3><h4 id="B树图示"><a href="#B树图示" class="headerlink" title="B树图示"></a>B树图示</h4><p>B树是为了磁盘或其它存储设备而设计的一种多叉（下面你会看到，相对于二叉，B树每个内结点有多个 分支，即多叉）平衡查找树。 多叉平衡</p><p><img src="/images/mysql/B+Tree.png" alt=""></p><ul><li><p>B树的高度一般都是在2-4这个高度，树的高度直接影响IO的读写次数</p></li><li><p>如果是三层树结构—支撑的数据可以达到20G，如果是四层树结构—支撑的数据可以达到几十T</p><p><strong>B和B+的区别</strong></p><p>B树和B+树的最大区别在于<strong>非叶子节点是否存储数据</strong>的问题。</p><p>B树是<strong>非叶子节点和叶子节点都会存储数据</strong>。</p><p>B+树<strong>只有叶子节点才会存储数据</strong>，而且存储的<strong>数据都是在一行上</strong>，而且这些数据都是<strong>有指针指向 的</strong>，也就是有<strong>顺序</strong>的。</p></li></ul><h3 id="5-3-非聚簇索引（MyISAM）"><a href="#5-3-非聚簇索引（MyISAM）" class="headerlink" title="5.3 非聚簇索引（MyISAM）"></a>5.3 非聚簇索引（MyISAM）</h3><p>对于MyISAM存储引擎，也是采用的是<strong>B+Tree</strong>索引， 由于MyISAM存储引擎，数据和索引是在不同的文件中的，因此不管是否是主键索引，<strong>B+Tree索引的叶子节点存储的是数据行的地址</strong>，不会存储行数据。</p><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p><img src="/images/mysql/myisam_primary_key.png" alt=""></p><h4 id="辅助索引（次要索引）"><a href="#辅助索引（次要索引）" class="headerlink" title="辅助索引（次要索引）"></a>辅助索引（次要索引）</h4><p><img src="/images/mysql/myisam_index.png" alt=""></p><h3 id="5-4-聚簇索引（InnoDB）"><a href="#5-4-聚簇索引（InnoDB）" class="headerlink" title="5.4 聚簇索引（InnoDB）"></a>5.4 聚簇索引（InnoDB）</h3><p>对于InnoDB，数据和索引是在一个文件中，InnoDB采用B+Tree索引，叶子节点上存储的是索引和数据，并非地址值。对于聚簇索引的主键索引，叶子节点存储的<strong>主键对应的一整行数据</strong>，对于非主键索引，叶子节点上存储的是<strong>主键值</strong>， 如果不是覆盖索引，那么会产生<strong>回表</strong>，降低查询速度。</p><p>对于聚集索引，表示的是数据和索引在一个文件中</p><h4 id="主键索引-1"><a href="#主键索引-1" class="headerlink" title="主键索引"></a>主键索引</h4><p><img src="/images/mysql/innodb_primary_key.png" alt=""></p><blockquote><p>注意： 叶子节点上的数据都是排序好的，从左到右是顺序排列的</p></blockquote><h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p><img src="/images/mysql/innodb_index.png" alt=""></p><p>这里，如果对name创建单值索引，叶子节点存储的索引值，然后通过name来信息的时候，如果使用的<strong>select *</strong>那么此时mysql，会根据叶子节点的主键值，从主键索引中查找的整行的数据。</p><p><strong>回表</strong>： 从辅助索引中查找到主键， 然后从主键索引中查找数据的过程，被称为”<strong>回表</strong>“</p><p>select * from t where name=’Alice’ 给name做了索引找两个索引树</p><p>select id,name from t where name=’Alice’ – 只查找了一次索引树，因为在辅助索引中，可以找到所有的数据。所以不需要回表**</p><p><strong>形成索引树覆盖索引</strong></p><p>覆盖索引，实质就是能够一次性从辅助索引树上，拿到所有的数据，不产生回表的操作。</p><p>利用组合索引 完成索引覆盖覆盖</p><p>score name 建立成一个索引</p>]]></content>
    
    <summary type="html">
    
      1. 是什么
官方介绍索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度， 也就是排序好的快速查询的数据结构。

2. 索引的优势和劣势
2.1 优势
 * 可以提高数据检索的效率，降低数据库的IO成本，类似于书的目录。 – 检索
   
    
    </summary>
    
    
      <category term="MySql" scheme="https://fchunbo.github.io/categories/MySql/"/>
    
      <category term="Basic" scheme="https://fchunbo.github.io/categories/MySql/Basic/"/>
    
    
      <category term="MySql" scheme="https://fchunbo.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql的数据文件</title>
    <link href="https://fchunbo.github.io/2019/08/02/mysql/01-mysql%E5%9F%BA%E7%A1%80/5.%20mysql%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://fchunbo.github.io/2019/08/02/mysql/01-mysql基础/5. mysql数据文件/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-09-03T23:36:40.000Z</updated>
    
    <content type="html"><![CDATA[<p># </p><h2 id="1-查看数据文件的位置"><a href="#1-查看数据文件的位置" class="headerlink" title="1. 查看数据文件的位置"></a>1. 查看数据文件的位置</h2><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'%datadir%'</span></span><br></pre></td></tr></table></figure><p><img src="/images/mysql/view_datadir.png" alt=""></p><h2 id="2-数据文件"><a href="#2-数据文件" class="headerlink" title="2. 数据文件"></a>2. 数据文件</h2><ul><li>InnoDB数据文件<ul><li>.frm文件： 主要存放与表相关的数据信息，主要包括表结构定义的信心</li><li>.ibd: 使用<strong>独享表空间</strong>存储表<strong>数据和索引</strong>信息，一张表对应一个ibd文件，也就是说，数据文件和索引文件在一个文件中。</li><li>ibdata文件： 使用<strong>共享表空间</strong>存储存储数据和索引信息，所有表共享使用一个或者多个ibdata文件 。</li></ul></li><li>MyIsam数据文件<ul><li><strong>.frm</strong>文件：<strong>主要存放与表相关的数据信息,主要包括</strong>表结构的定义信息</li><li><strong>.myd</strong>文件：<strong>主要用来存储</strong>表数据信息。</li><li><strong>.myi</strong>文件：<strong>主要用来存储</strong>表数据文件中任何索引的数据树。</li></ul></li></ul><p>从上述可以看出，InnoDB的数据和索引在一个文件中，而MyIsam的数据和索引是存在不同的文件中的。</p><p><img src="/images/mysql/mysql_data_dir.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      # 

1. 查看数据文件的位置
1


show variables like &#39;%datadir%&#39;




2. 数据文件
 * InnoDB数据文件 * .frm文件： 主要存放与表相关的数据信息，主要包括表结构定义的信心
    * .ibd: 使用独享表空间存储表数据和索引信息，一张表对
    
    </summary>
    
    
      <category term="MySql" scheme="https://fchunbo.github.io/categories/MySql/"/>
    
      <category term="Basic" scheme="https://fchunbo.github.io/categories/MySql/Basic/"/>
    
    
      <category term="MySql" scheme="https://fchunbo.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql中的日志</title>
    <link href="https://fchunbo.github.io/2019/08/02/mysql/01-mysql%E5%9F%BA%E7%A1%80/4.%20Mysql%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97/"/>
    <id>https://fchunbo.github.io/2019/08/02/mysql/01-mysql基础/4. Mysql中的日志/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-09-03T23:36:21.000Z</updated>
    
    <content type="html"><![CDATA[<p># </p><h2 id="1-物理结构"><a href="#1-物理结构" class="headerlink" title="1. 物理结构"></a>1. 物理结构</h2><ul><li>MySQL是通过文件系统对数据和索引进行存储的。</li><li><p>MySQL从物理结构上可以分为日志文件和数据索引文件。</p></li><li><p>MySQL在Linux中的数据索引文件和日志文件都在/var/lib/mysql目录下。</p></li><li><p>日志文件采用顺序IO方式存储、数据文件采用随机IO方式存储。</p></li></ul><p><img src="/images/mysql/order_io.png" alt=""></p><h2 id="2-日志文件"><a href="#2-日志文件" class="headerlink" title="2. 日志文件"></a>2. 日志文件</h2><ul><li><p>错误日志文件</p><p><strong>默认是开启的，而且从</strong>5.5.7<strong>以后无法关闭错误日志，</strong>错误日志记录了运行过程中<strong>遇到的所有严重的错误</strong>  <strong>信息</strong>,以及 MySQL<strong>每次启动和关闭的详细信息</strong>。位置： <strong>/var/log/mysqld.log</strong></p></li><li><p>二进制日志（bin log）</p><p>记录数据变化，binlog记录了<strong>数据库所有的ddl语句和dml语句</strong>，但不包括<strong>select</strong>语句内容<strong>，语句以事件的形式保存，描述了数据的变更顺序，binlog还包括了每个更新语句的执行时间信息。如果是DDL语句，则直接记录到binlog日志，而</strong>DML<strong>语句，必须通过事务提交才能记录到</strong>binlog<strong>日志中</strong>。 <strong><font color="red">生产中开启</font></strong></p><blockquote><p>主要：用于<strong>数据备份，恢复，主从复制</strong>。</p></blockquote><p>如果开启呢？</p><p>在<code>/etc/my.cnf</code>文件中的[mysqld] section中，进行如下配置</p> <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># bin-log</span><br><span class="line">log-bin=mysql-bin</span><br></pre></td></tr></table></figure><blockquote><p>注意： 打开之后，每重启一次mysql服务器，都会创建的一个新的mysql-bin文件</p></blockquote><p><img src="/images/mysql/bin-log.png" alt=""></p></li><li><p>通用查询日志</p><p>什么都记录， 耗性能，生产中不开启</p></li><li><p>慢查询日志</p><p>SQL调优 定位慢的select</p><p>默认是关闭，需要通过以下方式来进行开启：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#</span>开启慢查询日志</span><br><span class="line">slow_query_log=ON </span><br><span class="line"><span class="hljs-meta">#</span>慢查询的阈值</span><br><span class="line">long_query_time=3</span><br><span class="line"><span class="hljs-meta">#</span>日志记录文件如果没有给出file_name值， 默认为主机名，后缀为-slow.log。如果给出了文件名，但不是绝对路径名，文件则写入数据目录。</span><br><span class="line">slow_query_log_file=file_name</span><br></pre></td></tr></table></figure><p>记录执行时间超过long_query_time秒的所有查询，便于收集查询时间比较长的SQL语句</p></li><li><p>重做日志（redo log）</p></li><li><p>回滚日志 (undo log)</p></li><li><p>中继日志 （relay log）</p><p><img src="/images/mysql/sql_log.png" alt=""></p></li></ul><p>查看日志开启情况，使用如下命令：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'log_%'</span></span><br></pre></td></tr></table></figure><p><img src="/images/mysql/view_log_start_on.png" alt=""></p><p>查看数据文件的位置：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'%datadir%'</span></span><br></pre></td></tr></table></figure><p><img src="/images/mysql/view_datadir.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      # 

1. 物理结构
 * MySQL是通过文件系统对数据和索引进行存储的。
 * MySQL从物理结构上可以分为日志文件和数据索引文件。
   
   
 * MySQL在Linux中的数据索引文件和日志文件都在/var/lib/mysql目录下。
   
   
 * 日志文件采用顺序IO方式
    
    </summary>
    
    
      <category term="MySql" scheme="https://fchunbo.github.io/categories/MySql/"/>
    
      <category term="Basic" scheme="https://fchunbo.github.io/categories/MySql/Basic/"/>
    
    
      <category term="MySql" scheme="https://fchunbo.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql SQL执行顺序</title>
    <link href="https://fchunbo.github.io/2019/08/02/mysql/01-mysql%E5%9F%BA%E7%A1%80/3.%20MySQL%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>https://fchunbo.github.io/2019/08/02/mysql/01-mysql基础/3. MySQL执行顺序/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-09-03T23:34:39.000Z</updated>
    
    <content type="html"><![CDATA[<p># </p><h2 id="1-手写sql的顺序"><a href="#1-手写sql的顺序" class="headerlink" title="1. 手写sql的顺序"></a>1. 手写sql的顺序</h2><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span></span><br><span class="line">&lt; select_list &gt;</span><br><span class="line"><span class="hljs-keyword">FROM</span></span><br><span class="line">&lt; left_table &gt; &lt; join_type &gt;</span><br><span class="line"><span class="hljs-keyword">JOIN</span> &lt; right_table &gt; <span class="hljs-keyword">ON</span> &lt; join_condition &gt;</span><br><span class="line"><span class="hljs-keyword">WHERE</span></span><br><span class="line">&lt; where_condition &gt;</span><br><span class="line"><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span></span><br><span class="line">&lt; group_by_list &gt;</span><br><span class="line"><span class="hljs-keyword">HAVING</span></span><br><span class="line">&lt; having_condition &gt;</span><br><span class="line"><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span></span><br><span class="line">&lt; order_by_condition &gt;</span><br><span class="line"><span class="hljs-keyword">LIMIT</span> &lt; limit_number &gt;</span><br></pre></td></tr></table></figure><h2 id="2-mysql执行的顺序"><a href="#2-mysql执行的顺序" class="headerlink" title="2. mysql执行的顺序"></a>2. mysql执行的顺序</h2><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">-- 行过滤</span></span><br><span class="line">1 FROM &lt;left_table&gt;</span><br><span class="line">2 ON &lt;join_condition&gt;</span><br><span class="line">3 &lt;join_type&gt; JOIN &lt;right_table&gt; 第二步和第三步会循环执行</span><br><span class="line">4 WHERE &lt;where_condition第四步会循环执行，多个条件的执行顺序是从左往右的。</span><br><span class="line">5 GROUP BY &lt;group_by_list&gt;</span><br><span class="line">6 HAVING &lt;having_condition</span><br><span class="line"><span class="hljs-comment">--列过滤</span></span><br><span class="line">7 <span class="hljs-keyword">SELECT</span> 分组之后才会执行<span class="hljs-keyword">SELECT</span></span><br><span class="line"><span class="hljs-number">8</span> <span class="hljs-keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="hljs-comment">--排序</span></span><br><span class="line"><span class="hljs-number">9</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="hljs-comment">-- MySQL附加</span></span><br><span class="line"><span class="hljs-number">10</span> <span class="hljs-keyword">LIMIT</span> &lt;limit_number&gt; 前<span class="hljs-number">9</span>步都是SQL92标准语法。<span class="hljs-keyword">limit</span>是MySQL的独有语法。</span><br></pre></td></tr></table></figure><p><img src="/images/mysql/SQL_Parse.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      # 

1. 手写sql的顺序
1
2
3
4
5
6
7
8
9
10
11
12
13
14


SELECT DISTINCT
&lt; select_list &gt;
FROM
&lt; left_table &gt; &lt; join_type &gt;
JOIN &lt; right_table &gt; ON &lt; join_co
    
    </summary>
    
    
      <category term="MySql" scheme="https://fchunbo.github.io/categories/MySql/"/>
    
      <category term="Basic" scheme="https://fchunbo.github.io/categories/MySql/Basic/"/>
    
    
      <category term="MySql" scheme="https://fchunbo.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 逻辑架构</title>
    <link href="https://fchunbo.github.io/2019/08/02/mysql/01-mysql%E5%9F%BA%E7%A1%80/1.%20%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/"/>
    <id>https://fchunbo.github.io/2019/08/02/mysql/01-mysql基础/1. 逻辑架构/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-09-05T04:24:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-逻辑架构"><a href="#1-逻辑架构" class="headerlink" title="1. 逻辑架构"></a>1. 逻辑架构</h2><p><img src="/images/mysql/mysql_framework.png" alt=""></p><h2 id="2-逻辑架构说明"><a href="#2-逻辑架构说明" class="headerlink" title="2. 逻辑架构说明"></a>2. 逻辑架构说明</h2><h4 id="连接器（Connectors）"><a href="#连接器（Connectors）" class="headerlink" title="连接器（Connectors）"></a><strong>连接器（</strong>Connectors）</h4><p>也就是mysql的 连接驱动</p><p><strong>系统管理和控制工具（</strong>Management Serveices &amp; Utilities<strong>） </strong></p><p><strong>连接池（</strong>Connection Pool）</p><p>SQL Layer MySQL业务层</p><h4 id="SQL接口（SQL-Interface）"><a href="#SQL接口（SQL-Interface）" class="headerlink" title="SQL接口（SQL Interface）"></a><strong>SQL</strong>接口（SQL Interface）</h4><p>接收SQL DML DDL</p><h4 id="解析器（Parser）"><a href="#解析器（Parser）" class="headerlink" title="解析器（Parser）"></a>解析器（Parser）</h4><p>select * from t1</p><ul><li><p>词法分析 分词： 形成成语法树</p></li><li><p>语法分析 分析 ： 符合SQL的语法 SQL的语法 ： SQL 92 limit MYSQL自己的语法elect * from t1 语法错误 sytnx error ..</p></li></ul><p>形成正确语法树</p><p><strong>查询优化器（</strong>Optimizer**）</p><p> mysql 觉得你写的SQL 不是完美的优化什么呢？</p><ul><li>索引优化</li></ul><p>索引 只使用一个 使用最优</p><ul><li><p>多表关联优化</p><p>应该是小表关联大表，类似两层for循环一样</p></li><li><p>where 优化</p><p>从左到右 MySQL 找<strong>过滤力度最大</strong>的 先执行</p></li></ul><p>where id=1 and sex=’男’ where sex=’男’ and id=1 explain</p><p>从右到左 Oracle</p><h4 id="查询缓存（Cache和Buﬀer）"><a href="#查询缓存（Cache和Buﬀer）" class="headerlink" title="查询缓存（Cache和Buﬀer）"></a>查询缓存（Cache和Buﬀer）</h4><p>把查询结果存起来</p><p>SQL — &gt; hash后的值 唯一 则 表示</p><p>注意：SQL hash值是优化后的sql进行hash</p><h4 id="存储引擎（Pluggable-Storage-Engines）"><a href="#存储引擎（Pluggable-Storage-Engines）" class="headerlink" title="存储引擎（Pluggable Storage Engines）"></a>存储引擎（Pluggable Storage Engines）</h4><p>以表为单位，创建表时，指定存储引擎</p><p>creat table xxx() engine=InnoDB/Memory/MyISAM</p><p>MySQL的存储引擎是针对表进行指定的。（engine=InnoDB\myisam）</p><h2 id="3-存储引擎说明"><a href="#3-存储引擎说明" class="headerlink" title="3. 存储引擎说明"></a>3. 存储引擎说明</h2><table><thead><tr><th><strong>存储引擎</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>MyISAM</strong></td><td>高速引擎，拥有较高的插入，查询速度，<strong>但不支持事务、不支持行**</strong>锁**、支持3种不同的存储格式。包括静态型、动态型和压缩型。</td></tr><tr><td><strong>InnoDB</strong></td><td><strong>5.5</strong>版本后<strong>MySQL</strong>的默认数据库，支持事务和行级锁定<strong>，</strong>事务处理<strong>、</strong>回滚<strong>、</strong>崩溃修复能力<strong>和</strong>多版本并发控制<strong>的事务安全，比MyISAM处理速度稍慢、支持</strong>外键（<strong>FOREIGN KEY</strong>）</td></tr><tr><td>ISAM</td><td>MyISAM的前身，MySQL5.0以后不再默认安装</td></tr><tr><td>MRG_MyISAM（MERGE）</td><td>将多个表联合成一个表使用，在超大规模数据存储时很有用</td></tr><tr><td><strong>Memory</strong></td><td><strong>内存存储引擎，拥有极高的插入，更新和查询效率。</strong>但是会占用和数据量成正比的内存空间。只在内存上保存数据，意味着数据可能会丢失，比如临时表，就是放在内存中的</td></tr><tr><td>Falcon</td><td>一种新的存储引擎，支持事物处理，传言可能是InnoDB的替代者</td></tr><tr><td>Archive</td><td>将数据压缩后进行存储，非常适合存储大量的独立的，作为历史记录的数据，但是只能进行插入和查询操作</td></tr><tr><td>CSV</td><td>CSV 存储引擎是基于 CSV 格式文件存储数据(应用于跨平台的数据交换)</td></tr></tbody></table><h2 id="4-InnoDB和MyISAM存储引擎区别"><a href="#4-InnoDB和MyISAM存储引擎区别" class="headerlink" title="4. InnoDB和MyISAM存储引擎区别"></a>4. InnoDB和MyISAM存储引擎区别</h2><table><thead><tr><th></th><th><strong>Innodb</strong></th><th><strong>Myisam</strong></th></tr></thead><tbody><tr><td><strong>存储文件</strong></td><td>.frm 表定义文件<br>.ibd 数据文件和索引文件</td><td>.frm 表定义文件<br>.myd 数据文件<br>.myi 索引文件</td></tr><tr><td><strong>锁</strong></td><td>表锁、<strong>行锁</strong></td><td>表锁</td></tr><tr><td><strong>事务</strong></td><td>支持</td><td>不支持</td></tr><tr><td><strong>CRDU</strong></td><td>读、写</td><td>读多</td></tr><tr><td><strong>count</strong></td><td>扫表(count(1))</td><td>专门存储的地方 （加where也扫表）</td></tr><tr><td><strong>索引结构</strong></td><td>B+ Tree</td><td>B+ Tree</td></tr><tr><td>外键</td><td>支持</td><td>不支持</td></tr></tbody></table><blockquote><p>注意：从上表中可以看出，InnoDB存储引擎，数据文件和索引文件在一个文件中；而MyIsam存储的索引文件和数据文件是分开的。</p></blockquote><h2 id="5-存储引擎的选型："><a href="#5-存储引擎的选型：" class="headerlink" title="5. 存储引擎的选型："></a>5. 存储引擎的选型：</h2><p><strong>InnoDB</strong>：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要<strong>对事务的完整性要求比   较高</strong>（比如银行），<strong>要求实现并发控制</strong>（比如售票），那选择InnoDB有很大的优势。如果需要<strong>频繁的</strong>更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</p><p><strong>MyISAM</strong>：插入数据快，空间和内存使用比较低。如果表主要是<strong>用于插入新记录和读出记录</strong>，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。</p><p><strong>MEMORY</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要<strong>很快的读写速度</strong>，  对数据的安全性要求较低，不需要持久保存，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。(比的应用如临时表)</p><blockquote><p>注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择<strong>InnoDB</strong>。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的<strong>临时表</strong>，可以选择<strong>MEMORY存储引擎</strong></p></blockquote><h2 id="6-如何查看数据库默认的存储引擎"><a href="#6-如何查看数据库默认的存储引擎" class="headerlink" title="6. 如何查看数据库默认的存储引擎"></a>6. 如何查看数据库默认的存储引擎</h2><p>查看当前数据库支持的存储引擎，使用如下命令：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql/mysql_engines.png" alt=""></p><p>查看数据库默认使用的存储引擎: <strong>InnoDB</strong></p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like '%storage_engine%';</span><br></pre></td></tr></table></figure><p><img src="/images/mysql/default_mysql_engine.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      1. 逻辑架构


2. 逻辑架构说明
连接器（Connectors）
也就是mysql的 连接驱动

系统管理和控制工具（Management Serveices &amp; Utilities） 

连接池（Connection Pool）

SQL Layer MySQL业务层

SQL接口（SQL 
    
    </summary>
    
    
      <category term="MySql" scheme="https://fchunbo.github.io/categories/MySql/"/>
    
      <category term="Basic" scheme="https://fchunbo.github.io/categories/MySql/Basic/"/>
    
    
      <category term="MySql" scheme="https://fchunbo.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>go语言提供的静态服务器</title>
    <link href="https://fchunbo.github.io/2019/07/22/Go/package/http/go%E8%AF%AD%E8%A8%80%E6%8F%90%E4%BE%9B%E7%9A%84%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://fchunbo.github.io/2019/07/22/Go/package/http/go语言提供的静态服务器/</id>
    <published>2019-07-21T16:00:00.000Z</published>
    <updated>2019-09-03T15:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go语言提供的静态服务器"><a href="#go语言提供的静态服务器" class="headerlink" title="go语言提供的静态服务器"></a>go语言提供的静态服务器</h1><p>在go语言中，默认提供了静态的文件服务器，使用方法如下</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * @Author fchunbo</span></span><br><span class="line"><span class="hljs-comment"> * @Date 2019-03-18 13:42</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line">    <span class="hljs-string">"fmt"</span></span><br><span class="line">    <span class="hljs-string">"log"</span></span><br><span class="line">    <span class="hljs-string">"net/http"</span></span><br><span class="line">    <span class="hljs-string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    r.ParseForm() <span class="hljs-comment">// 解析参数，默认是不会解析的</span></span><br><span class="line">    fmt.Println(r.Form)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="hljs-string">"path： "</span>, r.URL.Path)</span><br><span class="line">    fmt.Println(<span class="hljs-string">"schema: "</span>, r.URL.Scheme)</span><br><span class="line"></span><br><span class="line">    fmt.Println(r.Form[<span class="hljs-string">"url_long"</span>])</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Form &#123;</span><br><span class="line">        fmt.Println(<span class="hljs-string">"key:"</span>, k)</span><br><span class="line">        fmt.Println(<span class="hljs-string">"value: "</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 给客户端返回结果</span></span><br><span class="line">    fmt.Fprintln(w, <span class="hljs-string">"hello rob"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="hljs-string">"/"</span>, sayHello)</span><br><span class="line"></span><br><span class="line">    wd, _ := os.Getwd()</span><br><span class="line">    http.Handle(<span class="hljs-string">"/static/"</span>, http.StripPrefix(<span class="hljs-string">"/static/"</span>, http.FileServer(http.Dir(wd))))</span><br><span class="line">    err := http.ListenAndServe(<span class="hljs-string">":8080"</span>, <span class="hljs-literal">nil</span>)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="hljs-string">"ListenServer:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：Go语言提供的静态文件服务器是基于绝对路径的，因此需要使用os.Getwd，来回去程序的路径。</p></blockquote><p>用法：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.Handle(<span class="hljs-string">"/static/"</span>, http.StripPrefix(<span class="hljs-string">"/static/"</span>, http.FileServer(http.Dir(wd))))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      go语言提供的静态服务器
在go语言中，默认提供了静态的文件服务器，使用方法如下

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39

    
    </summary>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/categories/Go/"/>
    
      <category term="http" scheme="https://fchunbo.github.io/categories/Go/http/"/>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go Http包WebServer运行的整个流程与原理</title>
    <link href="https://fchunbo.github.io/2019/07/22/Go/package/http/Go%20http%E5%8C%85web%20server%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://fchunbo.github.io/2019/07/22/Go/package/http/Go http包web server的原理/</id>
    <published>2019-07-21T16:00:00.000Z</published>
    <updated>2019-09-03T15:12:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Http包WebServer运行的整个流程与原理"><a href="#Http包WebServer运行的整个流程与原理" class="headerlink" title="Http包WebServer运行的整个流程与原理"></a>Http包WebServer运行的整个流程与原理</h1><p>讲解GO web server运行流程，使用如下例子来讲解。进行源码分析</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line">    <span class="hljs-string">"fmt"</span></span><br><span class="line">    <span class="hljs-string">"log"</span></span><br><span class="line">    <span class="hljs-string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    r.ParseForm() <span class="hljs-comment">// 解析参数，默认是不会解析的</span></span><br><span class="line">    fmt.Println(r.Form)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="hljs-string">"path： "</span>, r.URL.Path)</span><br><span class="line">    fmt.Println(<span class="hljs-string">"schema: "</span>, r.URL.Scheme)</span><br><span class="line"></span><br><span class="line">    fmt.Println(r.Form[<span class="hljs-string">"url_long"</span>])</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Form &#123;</span><br><span class="line">        fmt.Println(<span class="hljs-string">"key:"</span>, k)</span><br><span class="line">        fmt.Println(<span class="hljs-string">"value: "</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 给客户端返回结果</span></span><br><span class="line">    fmt.Fprintln(w, <span class="hljs-string">"hello rob"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="hljs-string">"/"</span>, sayHello)</span><br><span class="line">    err := http.ListenAndServe(<span class="hljs-string">":8080"</span>, <span class="hljs-literal">nil</span>)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="hljs-string">"ListenServer:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序就构成了一个简单的web server，是如何运行的呢？就从<code>main</code>函数开始讲解。</p><h2 id="Handler函数的注册"><a href="#Handler函数的注册" class="headerlink" title="Handler函数的注册"></a>Handler函数的注册</h2><p>首先注册我们handler函数</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="hljs-string">"/"</span>, sayHello)</span><br></pre></td></tr></table></figure><p><code>http.HandleFunc</code>函数的源码如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleFunc</span><span class="hljs-params">(pattern <span class="hljs-keyword">string</span>, handler <span class="hljs-keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，http.HandleFunc函数的实质是<code>DefaultServeMux</code>的HandleFunc方法，那么<code>DefaultServeMux</code>的定义为： </p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// DefaultServeMux is the default ServeMux used by Serve.</span></span><br><span class="line"><span class="hljs-keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> defaultServeMux ServeMux</span><br></pre></td></tr></table></figure><p>可以看出DefaultServeMux就是ServeMUX 指针类型。<code>ServeMux</code>的作用就是起到了默认的<code>路由器</code>的作用。定义如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> ServeMux <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">mu    sync.RWMutex</span><br><span class="line">m     <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]muxEntry</span><br><span class="line">hosts <span class="hljs-keyword">bool</span> <span class="hljs-comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其HandleFunc方法如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// HandleFunc registers the handler function for the given pattern.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span> <span class="hljs-title">HandleFunc</span><span class="hljs-params">(pattern <span class="hljs-keyword">string</span>, handler <span class="hljs-keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> handler == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-built_in">panic</span>(<span class="hljs-string">"http: nil handler"</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">// 这里调用了自身的Handle方法, HandlerFunc 函数类型</span></span><br><span class="line">mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Handle registers the handler for the given pattern.</span></span><br><span class="line"><span class="hljs-comment">// If a handler already exists for pattern, Handle panics.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span> <span class="hljs-title">Handle</span><span class="hljs-params">(pattern <span class="hljs-keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">mux.mu.Lock()</span><br><span class="line"><span class="hljs-keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> pattern == <span class="hljs-string">""</span> &#123;</span><br><span class="line"><span class="hljs-built_in">panic</span>(<span class="hljs-string">"http: invalid pattern"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> handler == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-built_in">panic</span>(<span class="hljs-string">"http: nil handler"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line"><span class="hljs-built_in">panic</span>(<span class="hljs-string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> mux.m == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">mux.m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]muxEntry)</span><br><span class="line">&#125;</span><br><span class="line">mux.m[pattern] = muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> pattern[<span class="hljs-number">0</span>] != <span class="hljs-string">'/'</span> &#123;</span><br><span class="line">mux.hosts = <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在改方法中，handler就是<code>sayHello</code>函数.<code>mux.Handle(pattern, HandlerFunc(handler))</code>中，<code>HandlerFunc(handler)</code> 是一个强制类型转换语句，HandlerFunc其实一个函数类型，实现了Handler接口。定义如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ResponseWriter, *Request)</span></span></span><br><span class="line"><span class="hljs-function"></span></span><br><span class="line"><span class="hljs-function">// <span class="hljs-title">ServeHTTP</span> <span class="hljs-title">calls</span> <span class="hljs-title">f</span><span class="hljs-params">(w, r)</span>. </span></span><br><span class="line"><span class="hljs-function"><span class="hljs-title">func</span> <span class="hljs-params">(f HandlerFunc)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">f(w, r) <span class="hljs-comment">// 调用HandlerFunc类型自身。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，HandlerFunc类型实现了<code>http.Handler</code>接口的<code>ServeHTTP</code>函数，也就说HandlerFunc也就是http.Handler类型。其中的 <code>ServeMux</code>的<code>Handle</code>方法，就实现了URI和Handler的映射。</p><h2 id="请求是如何到达后端的处理函数"><a href="#请求是如何到达后端的处理函数" class="headerlink" title="请求是如何到达后端的处理函数"></a>请求是如何到达后端的处理函数</h2><p>说明请求是如何到达后端函数，从如下语句说起：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := http.ListenAndServe(<span class="hljs-string">":8080"</span>, <span class="hljs-literal">nil</span>)</span><br></pre></td></tr></table></figure><p><code>http.ListenAndServe</code>函数，设置Web Server的端口，并监听客户端的请求</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(addr <span class="hljs-keyword">string</span>, handler Handler)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">  <span class="hljs-comment">// 创建server，我们设置的handler为nil，相当于默认使用ServeMux去处理</span></span><br><span class="line">server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">// 调用了Server的ListenAndServe()方法</span></span><br><span class="line"><span class="hljs-keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Server的ListenAndServe()方法的源码如下：</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> srv.shuttingDown() &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ErrServerClosed</span><br><span class="line">&#125;</span><br><span class="line">addr := srv.Addr</span><br><span class="line"><span class="hljs-keyword">if</span> addr == <span class="hljs-string">""</span> &#123;</span><br><span class="line">addr = <span class="hljs-string">":http"</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">// 调用net包中的Listen函数，监听网络</span></span><br><span class="line">ln, err := net.Listen(<span class="hljs-string">"tcp"</span>, addr)</span><br><span class="line"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Server 的Serve方法的源码如下</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span> <span class="hljs-title">Serve</span><span class="hljs-params">(l net.Listener)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> fn := testHookServerServe; fn != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">fn(srv, l) <span class="hljs-comment">// call hook with unwrapped listener</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l = &amp;onceCloseListener&#123;Listener: l&#125;</span><br><span class="line"><span class="hljs-keyword">defer</span> l.Close()</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> err := srv.setupHTTP2_Serve(); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> !srv.trackListener(&amp;l, <span class="hljs-literal">true</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ErrServerClosed</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">defer</span> srv.trackListener(&amp;l, <span class="hljs-literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> tempDelay time.Duration     <span class="hljs-comment">// how long to sleep on accept failure</span></span><br><span class="line">baseCtx := context.Background() <span class="hljs-comment">// base is always background, per Issue 16220</span></span><br><span class="line">ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line"><span class="hljs-keyword">for</span> &#123;</span><br><span class="line">rw, e := l.Accept() <span class="hljs-comment">// 阻塞监听客户端的连接</span></span><br><span class="line"><span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line"><span class="hljs-keyword">select</span> &#123;</span><br><span class="line"><span class="hljs-keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line"><span class="hljs-keyword">return</span> ErrServerClosed</span><br><span class="line"><span class="hljs-keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> tempDelay == <span class="hljs-number">0</span> &#123;</span><br><span class="line">tempDelay = <span class="hljs-number">5</span> * time.Millisecond</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">tempDelay *= <span class="hljs-number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> max := <span class="hljs-number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">tempDelay = max</span><br><span class="line">&#125;</span><br><span class="line">srv.logf(<span class="hljs-string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</span><br><span class="line">time.Sleep(tempDelay)</span><br><span class="line"><span class="hljs-keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line">tempDelay = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-comment">// 这里表示，有客户端的请求进来</span></span><br><span class="line">    <span class="hljs-comment">// 调用Server的newConn方法，获取到一个连接</span></span><br><span class="line">c := srv.newConn(rw)</span><br><span class="line">c.setState(c.rwc, StateNew) <span class="hljs-comment">// before Serve can return</span></span><br><span class="line"><span class="hljs-keyword">go</span> c.serve(ctx) <span class="hljs-comment">// 使用goroutines处理我们的请求</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Create new connection from rwc.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span> <span class="hljs-title">newConn</span><span class="hljs-params">(rwc net.Conn)</span> *<span class="hljs-title">conn</span></span> &#123;</span><br><span class="line">c := &amp;conn&#123;</span><br><span class="line">server: srv, <span class="hljs-comment">// 将Server实例传入，初始化conn</span></span><br><span class="line">rwc:    rwc,</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> debugServerConnections &#123;</span><br><span class="line">c.rwc = newLoggingConn(<span class="hljs-string">"server"</span>, c.rwc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意: c 为<code>conn</code>实例，代表HTTP Server端的一个连接，内部封装Server对象信息。</p><p><code>c.serve(ctx)</code>语句就是处理用户请求，其源码如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Serve a new connection.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span> <span class="hljs-title">serve</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">c.remoteAddr = c.rwc.RemoteAddr().String()</span><br><span class="line">ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())</span><br><span class="line"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &amp;&amp; err != ErrAbortHandler &#123;</span><br><span class="line"><span class="hljs-keyword">const</span> size = <span class="hljs-number">64</span> &lt;&lt; <span class="hljs-number">10</span></span><br><span class="line">buf := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, size)</span><br><span class="line">buf = buf[:runtime.Stack(buf, <span class="hljs-literal">false</span>)]</span><br><span class="line">c.server.logf(<span class="hljs-string">"http: panic serving %v: %v\n%s"</span>, c.remoteAddr, err, buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> !c.hijacked() &#123;</span><br><span class="line">c.<span class="hljs-built_in">close</span>()</span><br><span class="line">c.setState(c.rwc, StateClosed)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">.....<span class="hljs-comment">// 省略</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// HTTP cannot have multiple simultaneous active requests.[*]</span></span><br><span class="line"><span class="hljs-comment">// Until the server replies to this request, it can't read another,</span></span><br><span class="line"><span class="hljs-comment">// so we might as well run the handler in this goroutine.</span></span><br><span class="line"><span class="hljs-comment">// [*] Not strictly true: HTTP pipelining. We could let them all process</span></span><br><span class="line"><span class="hljs-comment">// in parallel even if their responses need to be serialized.</span></span><br><span class="line"><span class="hljs-comment">// But we're not going to implement HTTP pipelining because it</span></span><br><span class="line"><span class="hljs-comment">// was never deployed in the wild and the answer is HTTP/2.</span></span><br><span class="line">    <span class="hljs-comment">// 内部的serverHandler结构体，获取Server对象，创建</span></span><br><span class="line">    <span class="hljs-comment">// serverHandler实例，并调用ServerHTTP方法</span></span><br><span class="line">serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line"> .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>serverHandler结构体的ServeHTTP方法如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// serverHandler delegates to either the server's Handler or</span></span><br><span class="line"><span class="hljs-comment">// DefaultServeMux and also handles "OPTIONS *" requests.</span></span><br><span class="line"><span class="hljs-keyword">type</span> serverHandler <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">srv *Server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sh serverHandler)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line"><span class="hljs-comment">// 首先去获取Server的Handler，我们初始化的时候为nil，从这里可以看出</span></span><br><span class="line">  <span class="hljs-comment">// 我们可以实现Handler来接管默认的路由器</span></span><br><span class="line">  handler := sh.srv.Handler</span><br><span class="line"><span class="hljs-keyword">if</span> handler == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// 如果handler为nil， 就使用DefaultServeMux,也就是默认的路由器</span></span><br><span class="line">handler = DefaultServeMux</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> req.RequestURI == <span class="hljs-string">"*"</span> &amp;&amp; req.Method == <span class="hljs-string">"OPTIONS"</span> &#123;</span><br><span class="line">handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">// 调用ServerMux的ServeHTTP方法， 实现路由</span></span><br><span class="line">handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServerMux的ServeHTTP方法如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// ServeHTTP dispatches the request to the handler whose</span></span><br><span class="line"><span class="hljs-comment">// pattern most closely matches the request URL.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> r.RequestURI == <span class="hljs-string">"*"</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> r.ProtoAtLeast(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &#123;</span><br><span class="line">w.Header().Set(<span class="hljs-string">"Connection"</span>, <span class="hljs-string">"close"</span>)</span><br><span class="line">&#125;</span><br><span class="line">w.WriteHeader(StatusBadRequest)</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">// 根据request的URI获取对应的Handler，这里就是我们的HandlerFunc类型的handler</span></span><br><span class="line">h, _ := mux.Handler(r)</span><br><span class="line">h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span> <span class="hljs-title">Handler</span><span class="hljs-params">(r *Request)</span> <span class="hljs-params">(h Handler, pattern <span class="hljs-keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// CONNECT requests are not canonicalized.</span></span><br><span class="line"><span class="hljs-keyword">if</span> r.Method == <span class="hljs-string">"CONNECT"</span> &#123;</span><br><span class="line"><span class="hljs-comment">// If r.URL.Path is /tree and its handler is not registered,</span></span><br><span class="line"><span class="hljs-comment">// the /tree -&gt; /tree/ redirect applies to CONNECT requests</span></span><br><span class="line"><span class="hljs-comment">// but the path canonicalization does not.</span></span><br><span class="line"><span class="hljs-keyword">if</span> u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> mux.handler(r.Host, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// All other requests have any port stripped and path cleaned</span></span><br><span class="line"><span class="hljs-comment">// before passing to mux.handler.</span></span><br><span class="line">host := stripHostPort(r.Host)</span><br><span class="line">path := cleanPath(r.URL.Path)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// If the given path is /tree and its handler is not registered,</span></span><br><span class="line"><span class="hljs-comment">// redirect for /tree/.</span></span><br><span class="line"><span class="hljs-keyword">if</span> u, ok := mux.redirectToPathSlash(host, path, r.URL); ok &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> path != r.URL.Path &#123;</span><br><span class="line">_, pattern = mux.handler(host, path)</span><br><span class="line">url := *r.URL</span><br><span class="line">url.Path = path</span><br><span class="line"><span class="hljs-keyword">return</span> RedirectHandler(url.String(), StatusMovedPermanently), pattern</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> mux.handler(host, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span> <span class="hljs-title">handler</span><span class="hljs-params">(host, path <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(h Handler, pattern <span class="hljs-keyword">string</span>)</span></span> &#123;</span><br><span class="line">mux.mu.RLock()</span><br><span class="line"><span class="hljs-keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Host-specific pattern takes precedence over generic ones</span></span><br><span class="line"><span class="hljs-keyword">if</span> mux.hosts &#123;</span><br><span class="line">h, pattern = mux.match(host + path)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">h, pattern = mux.match(path)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">h, pattern = NotFoundHandler(), <span class="hljs-string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当获取到HandlerFunc类型Handler时，就会调用去调用自己，HandlerFunc的ServeHTTP方法如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f HandlerFunc)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">f(w, r) <span class="hljs-comment">// 调用自己，也就是我们注册的后台处理方法。在这个例子中就是调用sayhello函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go-代码执行流程"><a href="#Go-代码执行流程" class="headerlink" title="Go 代码执行流程"></a>Go 代码执行流程</h3><p>通过对http包的分析之后，现在让我们来梳理一下整个的代码执行过程。<br>首先调用Http.HandleFunc<br>按顺序做了几件事：</p><ul><li><p>调用了DefaultServeMux的HandleFunc</p></li><li><p>调用了DefaultServeMux的Handle</p></li><li><p>往DefaultServeMux的map[string]muxEntry中增加对应的handler和路由规则</p></li><li><p>其次调用http.ListenAndServe(“:9090”, nil)， 按顺序做了几件事情:</p><ul><li><p>实例化Server</p></li><li><p>调用Server的ListenAndServe()</p></li><li><p>调用net.Listen(“tcp”, addr)监听端口</p></li><li><p>启动一个for循环，在循环体中Accept请求</p></li><li><p>对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务<code>go c.serve()</code></p></li><li><p>读取每个请求的内容w, err := c.readRequest()</p></li><li><p>判断handler是否为空，如果没有设置handler（ 这个例子就没有设置handler） ，handler就设置为<br>DefaultServeMux</p></li><li><p>调用handler的ServeHttp</p></li><li><p>在这个例子中，下面就进入到DefaultServeMux.ServeHttp</p></li><li><p>根据request选择handler，并且进入到这个handler的ServeHTTP </p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mux.handler(r).ServeHTTP(w, r)</span><br></pre></td></tr></table></figure></li><li><p>选择handler：<br>A 判断是否有路由能满足这个request（ 循环遍历ServeMux的muxEntry）<br>B 如果有路由满足，调用这个路由handler的ServeHTTP<br>C 如果没有路由满足，调用NotFoundHandler的ServeHTTP</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Http包WebServer运行的整个流程与原理
讲解GO web server运行流程，使用如下例子来讲解。进行源码分析

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32

    
    </summary>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/categories/Go/"/>
    
      <category term="http" scheme="https://fchunbo.github.io/categories/Go/http/"/>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>9. Go 内存模型</title>
    <link href="https://fchunbo.github.io/2019/04/21/Go/9.Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://fchunbo.github.io/2019/04/21/Go/9.Go语言的内存模型/</id>
    <published>2019-04-20T16:00:00.000Z</published>
    <updated>2019-09-03T15:15:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>暂时未研究</p>]]></content>
    
    <summary type="html">
    
      暂时未研究
    
    </summary>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>http包中serverHandler类型的分析</title>
    <link href="https://fchunbo.github.io/2019/04/19/Go/package/http/serverHander%E7%9A%84%E5%88%86%E6%9E%90/"/>
    <id>https://fchunbo.github.io/2019/04/19/Go/package/http/serverHander的分析/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-09-03T15:24:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="http包中serverHandler类型的分析"><a href="#http包中serverHandler类型的分析" class="headerlink" title="http包中serverHandler类型的分析"></a>http包中serverHandler类型的分析</h1><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// serverHandler delegates to either the server's Handler or</span></span><br><span class="line"><span class="hljs-comment">// DefaultServeMux and also handles "OPTIONS *" requests.</span></span><br><span class="line"><span class="hljs-keyword">type</span> serverHandler <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">srv *Server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sh serverHandler)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">handler := sh.srv.Handler</span><br><span class="line"><span class="hljs-keyword">if</span> handler == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">handler = DefaultServeMux</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> req.RequestURI == <span class="hljs-string">"*"</span> &amp;&amp; req.Method == <span class="hljs-string">"OPTIONS"</span> &#123;</span><br><span class="line">handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>serverHandler</code>是一个结构体，在结构体中，只有一个字段<code>sv *Server</code>, 这里在实际运行的过程中，保存了最开始创建的Server实例，包好了服务端Ip端口信息，Handler信息等。</p><p><code>serverHandler</code>也实现了http.Handler接口，我们看一下其ServeHTTP方法的实现：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler := sh.srv.Handler</span><br></pre></td></tr></table></figure><p>这里是在获取Server实例中的Handler对象，也就是在调用<code>http.ListenAndServe</code>函数，传入的Handler。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> handler == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">handler = DefaultServeMux</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里判断handler如果为空，就使用默认的handler，ServeMux。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler.ServeHTTP(rw, req)</span><br></pre></td></tr></table></figure><p>这里就调用handler的ServeHTTP方法了，要么进入到自定义的handler中，要么进入到<code>ServeMux</code>handler中。</p><p>接下来我们，我们看一下serverHandler的使用的地方。其实<code>serverHandler</code>是在接收到客户端的请求后，调用Conn的<code>serve</code>方法中使用的。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">go</span> c.serve(ctx) <span class="hljs-comment">// 使用goroutines处理我们的请求</span></span><br></pre></td></tr></table></figure><p>Conn的server方法如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Serve a new connection.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span> <span class="hljs-title">serve</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">c.remoteAddr = c.rwc.RemoteAddr().String()</span><br><span class="line">ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())</span><br><span class="line"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &amp;&amp; err != ErrAbortHandler &#123;</span><br><span class="line"><span class="hljs-keyword">const</span> size = <span class="hljs-number">64</span> &lt;&lt; <span class="hljs-number">10</span></span><br><span class="line">buf := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, size)</span><br><span class="line">buf = buf[:runtime.Stack(buf, <span class="hljs-literal">false</span>)]</span><br><span class="line">c.server.logf(<span class="hljs-string">"http: panic serving %v: %v\n%s"</span>, c.remoteAddr, err, buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> !c.hijacked() &#123;</span><br><span class="line">c.<span class="hljs-built_in">close</span>()</span><br><span class="line">c.setState(c.rwc, StateClosed)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">.....<span class="hljs-comment">// 省略</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// HTTP cannot have multiple simultaneous active requests.[*]</span></span><br><span class="line"><span class="hljs-comment">// Until the server replies to this request, it can't read another,</span></span><br><span class="line"><span class="hljs-comment">// so we might as well run the handler in this goroutine.</span></span><br><span class="line"><span class="hljs-comment">// [*] Not strictly true: HTTP pipelining. We could let them all process</span></span><br><span class="line"><span class="hljs-comment">// in parallel even if their responses need to be serialized.</span></span><br><span class="line"><span class="hljs-comment">// But we're not going to implement HTTP pipelining because it</span></span><br><span class="line"><span class="hljs-comment">// was never deployed in the wild and the answer is HTTP/2.</span></span><br><span class="line">    <span class="hljs-comment">// 内部的serverHandler结构体，获取Server对象，创建</span></span><br><span class="line">    <span class="hljs-comment">// serverHandler实例，并调用ServerHTTP方法</span></span><br><span class="line">serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line"> .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个代码中，可以看出，serverHandler起到了承上启下的作用，由于路由到了我们自定义的handler或ServeMux Handler中， 从而路由到我们的实现的Handler函数。</p>]]></content>
    
    <summary type="html">
    
      http包中serverHandler类型的分析
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16


// serverHandler delegates to either the server&#39;s Handler or
// DefaultServeMux and 
    
    </summary>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/categories/Go/"/>
    
      <category term="http" scheme="https://fchunbo.github.io/categories/Go/http/"/>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>8. Go Channel的使用</title>
    <link href="https://fchunbo.github.io/2019/04/03/Go/8.Channel/"/>
    <id>https://fchunbo.github.io/2019/04/03/Go/8.Channel/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-09-03T15:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go-Channel"><a href="#Go-Channel" class="headerlink" title="Go Channel"></a>Go Channel</h2><p>在Go中，多个goroutines推荐使用channel来进行通信。使用channel来共享内存。</p><p>go中channel有三种类型：<code>读写channel</code>, <code>只读channel</code>，<code>只写的channel</code></p><p>默认为读写的channel：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span><br></pre></td></tr></table></figure><p>同时channel还可以有缓存。定义如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>)</span><br></pre></td></tr></table></figure><p>上述定义了带有2个元素缓存的，channel</p><p>一般只读或只写的channel，大多出现在函数传参中，当然也可以直接定义：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 := <span class="hljs-built_in">make</span>(&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>) <span class="hljs-comment">// 定义了一个只读的channel</span></span><br><span class="line">c2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> &lt;-<span class="hljs-keyword">int</span>) <span class="hljs-comment">// 定义了一个只写的channel</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>对于缓存的channel，写数据也是阻塞的，直到将channel中的数据读出；读也是阻塞的，直到channel中有数据可读</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">  c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)</span><br><span class="line">    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="hljs-string">"Go GO Go !!"</span>)</span><br><span class="line">        c &lt;- <span class="hljs-literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">  </span><br><span class="line">   &lt;- c <span class="hljs-comment">// 等待读取数据，</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>对于带缓存的channel，在使用时，一定要注意如下情况：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 下面这种情况，需要注意，channel是否有缓存</span></span><br><span class="line"><span class="hljs-comment">// 否则在实际的开发中，很有可能goroutines还没有执行</span></span><br><span class="line"><span class="hljs-comment">// 程序就结束了。</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//c := make(chan bool, 1)</span></span><br><span class="line">    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)</span><br><span class="line">    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="hljs-string">"Go GO Go !!"</span>)</span><br><span class="line">        &lt;- c</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 对于无缓存时，如果没有读取channle中的数据，写也是阻塞的,必须将数据</span></span><br><span class="line">    <span class="hljs-comment">// 读取了之后，才能退出</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 对于有缓存的channel，我把数据写进去就是，不管你是否读取。</span></span><br><span class="line">    c &lt;- <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="判断channel是否关闭"><a href="#判断channel是否关闭" class="headerlink" title="判断channel是否关闭"></a>判断channel是否关闭</h2><p>判断channnel是否关闭，是在接收channel的数据时候，判断的：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;-c <span class="hljs-comment">// 如果channel关闭了，ok = false</span></span><br></pre></td></tr></table></figure><p>特别在<code>for range</code>循环遍历channel时，必须使用<code>Close()</code>函数关闭channnel，表示结束数据的写入，同时for循环也终止。</p>]]></content>
    
    <summary type="html">
    
      Go Channel
在Go中，多个goroutines推荐使用channel来进行通信。使用channel来共享内存。

go中channel有三种类型：读写channel, 只读channel，只写的channel

默认为读写的channel：

1


c := make(chan int)
    
    </summary>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>7. Go 中接口的理解</title>
    <link href="https://fchunbo.github.io/2019/03/31/Go/7.%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://fchunbo.github.io/2019/03/31/Go/7.接口的理解/</id>
    <published>2019-03-30T16:00:00.000Z</published>
    <updated>2019-09-03T15:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口的理解"><a href="#接口的理解" class="headerlink" title="接口的理解"></a>接口的理解</h1><p>在Go中的接口就是一些方法的集合，在接口只能定义方法，不能像Java那样还能定义一些常量。并且在Go中接口的实现方式，采用的是<code>Duck Type</code>，只要某个结构具有接口的方法，那么就实现了接口。Go中的接口，是隐式实现的，不必显示的声明。例如：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// http handler 接口</span></span><br><span class="line"><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;</span><br><span class="line">  ServeHTTP(w http.ResponseWriter, r *http.Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 实现该接口</span></span><br><span class="line"><span class="hljs-keyword">type</span> MyHandler <span class="hljs-keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MyHandler)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w http.ResponseWrite, r *http.Request)</span></span> &#123;</span><br><span class="line">  fmt.Fprintln(w, <span class="hljs-string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，就可以说，MyHandler就实现了http.Handler接口。在Go语言中接口的实现，可以理解为：像什么就是什么。</p><p>注意：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将对象赋值给接口变量时，会发生拷贝，就像函数或方法传参一样，是值拷贝。在接口变量内部存储的是指向这个复制品的指针，即无法修改复制品的状态，也无法获取指针。</span><br></pre></td></tr></table></figure><p>也就说，将对象赋值给接口变量后，对象中的字段改变，不会反映到接口变量指向的复制品中。例子如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * @Author fchunbo</span></span><br><span class="line"><span class="hljs-comment"> * @Date 2019-03-31 17:35</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> USB <span class="hljs-keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="hljs-keyword">string</span></span><br><span class="line">    Connect()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> PhoneConnector <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    name <span class="hljs-keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 注意：和函数是可以转换的</span></span><br><span class="line"><span class="hljs-comment">// 并且，对于类型的方法，接收者强制为方法的第一个参数。</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pc PhoneConnector)</span> <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> pc.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pc PhoneConnector)</span> <span class="hljs-title">Connect</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="hljs-string">"Connected: "</span>, pc.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> usb USB</span><br><span class="line">    <span class="hljs-keyword">var</span> pc PhoneConnector = PhoneConnector&#123;<span class="hljs-string">"iPhone"</span>&#125;</span><br><span class="line"></span><br><span class="line">    usb = pc <span class="hljs-comment">// 注意这里发生了值拷贝，usb内存存储了指向复制品的指针。</span></span><br><span class="line">    usb.Connect() <span class="hljs-comment">// iPhone</span></span><br><span class="line"></span><br><span class="line">    pc.name = <span class="hljs-string">"andriod"</span></span><br><span class="line">    usb.Connect() <span class="hljs-comment">// iPhone</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      接口的理解
在Go中的接口就是一些方法的集合，在接口只能定义方法，不能像Java那样还能定义一些常量。并且在Go中接口的实现方式，采用的是Duck Type，只要某个结构具有接口的方法，那么就实现了接口。Go中的接口，是隐式实现的，不必显示的声明。例如：

1
2
3
4
5
6
7
8
9
10

    
    </summary>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>5. Go 闭包</title>
    <link href="https://fchunbo.github.io/2019/03/28/Go/5.%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%B3%A8%E6%84%8F/"/>
    <id>https://fchunbo.github.io/2019/03/28/Go/5.函数闭包的使用以及注意/</id>
    <published>2019-03-27T16:00:00.000Z</published>
    <updated>2019-09-03T15:14:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a>函数的闭包</h1><p>在<code>GO</code>语言中，是支持函数的闭包的，具体用法如下例子：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    f := liner(<span class="hljs-number">10</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(f(<span class="hljs-number">1</span>))</span><br><span class="line">    fmt.Println(f(<span class="hljs-number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 这是一个闭包的例子</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">liner</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="hljs-string">"%v\n"</span>, &amp;x)</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="hljs-string">"%v\n"</span>, &amp;x)</span><br><span class="line">        <span class="hljs-keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0xc000062008</span><br><span class="line">0xc000062008</span><br><span class="line">11</span><br><span class="line">0xc000062008</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>对于闭包，自己的理解就是：在函数中的匿名函数，使用了外部函数的变量。外部函数调用之后，返回的函数，在使用过程中，外部函数的变量一直未被销毁，感觉上就像是外部函数的变量，一直被内部的匿名函数给”包裹”，始终拥有外部函数变量的引用。</p><p>从打印结果看，外部变量的地址和匿名函数调用时，使用的x是同一变量。</p><p>注意: 在循环中使用<code>defer</code></p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    </span><br><span class="line">    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i ++ &#123;</span><br><span class="line">        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的原本的想要的结果为：<code>0 1 2</code> 但是上述代码执行的结果为: </p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-number">3</span></span><br></pre></td></tr></table></figure><p>为什么会这样呢？其实这也是闭包的使用，在defer函数使用i其实是对变量<code>i</code>的引用，当循环结果后，i的值为3，既然defer修饰的函数是对变量<code>i</code>的引用，所以所有的defer函数都打印出了3.</p><p>所以，在使用defer修饰的匿名函数时，一定要注意，慎重使用所在函数的变量。</p><p>为了加深印象, 打印如下代码的结果：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> fs = [<span class="hljs-number">4</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;</span><br><span class="line">        <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">"defer i = "</span>, i)</span><br><span class="line"></span><br><span class="line">      <span class="hljs-comment">// 这也是闭包</span></span><br><span class="line">        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">            fmt.Println(<span class="hljs-string">"defer_closure i = "</span>, i)<span class="hljs-comment">// 保存了i的引用</span></span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 这也是闭包，这里只是保存了i变量的引用</span></span><br><span class="line">        fs[i] = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="hljs-string">"closure i = "</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> fs &#123;</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">closure i =  <span class="hljs-number">4</span></span><br><span class="line">closure i =  <span class="hljs-number">4</span></span><br><span class="line">closure i =  <span class="hljs-number">4</span></span><br><span class="line">closure i =  <span class="hljs-number">4</span></span><br><span class="line">defer_closure i =  <span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-keyword">defer</span> i =  <span class="hljs-number">3</span></span><br><span class="line">defer_closure i =  <span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-keyword">defer</span> i =  <span class="hljs-number">2</span></span><br><span class="line">defer_closure i =  <span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-keyword">defer</span> i =  <span class="hljs-number">1</span></span><br><span class="line">defer_closure i =  <span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-keyword">defer</span> i =  <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      函数的闭包
在GO语言中，是支持函数的闭包的，具体用法如下例子：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18


func main() {

    f := liner(10)

    fmt.Println(f(1))
    fmt.Prin
    
    </summary>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>6. Go 语言中结构体的使用</title>
    <link href="https://fchunbo.github.io/2019/03/28/Go/6.struct/"/>
    <id>https://fchunbo.github.io/2019/03/28/Go/6.struct/</id>
    <published>2019-03-27T16:00:00.000Z</published>
    <updated>2019-09-03T15:14:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go语言中结构体的使用"><a href="#go语言中结构体的使用" class="headerlink" title="go语言中结构体的使用"></a>go语言中结构体的使用</h1><h3 id="1-结构体的定义格式"><a href="#1-结构体的定义格式" class="headerlink" title="1. 结构体的定义格式"></a>1. 结构体的定义格式</h3><p>在go语言中结果的定义格式如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> structName <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">  filedList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>列子如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="hljs-keyword">string</span></span><br><span class="line">  age <span class="hljs-keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上上述这种方式定义的结构体有如下几种初始化的方式</p><ul><li><p>默认的方式， 这种方式也是零值初始化方式</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p := Person&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用字面量进行初始化</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := Person&#123;<span class="hljs-string">"Joe"</span>, <span class="hljs-number">19</span>&#125; <span class="hljs-comment">// 注意此时必须按照顺序初始化</span></span><br><span class="line">pp := Person&#123;age: <span class="hljs-number">19</span>, Name: <span class="hljs-string">"Joe"</span>&#125; <span class="hljs-comment">// 指定fieldname方式赋值，不用按照顺序</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-匿名结构体的使用"><a href="#2-匿名结构体的使用" class="headerlink" title="2. 匿名结构体的使用"></a>2. 匿名结构体的使用</h3><p>对于匿名结构体，可以在初始化变量的时定义，如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">  user := <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="hljs-keyword">string</span></span><br><span class="line">    Age <span class="hljs-keyword">int</span></span><br><span class="line">  &#125; &#123;Name: <span class="hljs-string">"joe"</span>, Age: <span class="hljs-number">19</span> &#125;</span><br><span class="line">  </span><br><span class="line">  fmt.Println(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">user := <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="hljs-keyword">string</span></span><br><span class="line">        Age <span class="hljs-keyword">int</span></span><br><span class="line">    &#125;&#123;<span class="hljs-string">"jor"</span>, <span class="hljs-number">10</span>&#125;</span><br></pre></td></tr></table></figure><p>同样在定义结构体时，也可以使用匿名结构体, 如下：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="hljs-keyword">string</span> </span><br><span class="line">  Age <span class="hljs-keyword">int</span></span><br><span class="line">  Content <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 匿名结构体</span></span><br><span class="line">    Tel <span class="hljs-keyword">string</span></span><br><span class="line">    Email <span class="hljs-keyword">string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于在结构体中的匿名结构体，在初始化的时候，需要如下操作：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">  user := &#123;Name: <span class="hljs-string">"joe"</span>, Age: <span class="hljs-number">10</span>&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">// 对于结构体中的匿名结构体只能这样初始化</span></span><br><span class="line">  user.Content.Tel = <span class="hljs-string">"12306"</span></span><br><span class="line">  user.Content.Email = <span class="hljs-string">"214639811@qq.com"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在GO中结构体，就是某些字段的集合，是值类型的，可以进行 <code>==</code>比较的，注意必须是相同类型的结构体。</p><h3 id="3-结构体中的匿名字段"><a href="#3-结构体中的匿名字段" class="headerlink" title="3. 结构体中的匿名字段"></a>3. 结构体中的匿名字段</h3><p>结构体中的匿名字段，可以是GO语言内置的，也可以是自定义的类型。GO内置的类型，例子如下:</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span>&#123;</span><br><span class="line">  <span class="hljs-keyword">string</span></span><br><span class="line">  <span class="hljs-keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种结构体，必须按照顺序进行初始化。</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">  p := Person&#123;<span class="hljs-string">"joe"</span>, <span class="hljs-number">10</span>&#125;</span><br><span class="line">  fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在go中没有继承机制，自定义类型的匿名字段在go中叫做组合继承，如下</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> human <span class="hljs-keyword">struct</span>&#123;</span><br><span class="line">  Sex <span class="hljs-keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span>&#123;</span><br><span class="line">  human <span class="hljs-comment">// 注意：匿名字段，类型名和字段名是一致的</span></span><br><span class="line">  Name <span class="hljs-keyword">string</span></span><br><span class="line">  Age <span class="hljs-keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种结构体的初始化，按照顺序初始化，如下</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">  p := Person&#123;human&#123;Sex: <span class="hljs-string">"f"</span>&#125;, <span class="hljs-string">"joe"</span>, <span class="hljs-number">20</span>&#125;</span><br><span class="line">  fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定字段名进行初始化</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">  p := Person&#123;Name: <span class="hljs-string">"joe"</span>, Age: <span class="hljs-number">10</span>, human: human&#123;Sex: <span class="hljs-string">"f"</span>&#125;&#125;</span><br><span class="line">  p := Person&#123;Name: <span class="hljs-string">"joe"</span>, Age: <span class="hljs-number">10</span>, human: human&#123;Sex: <span class="hljs-string">"f"</span>&#125;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">// 注意： 对于结构体中的匿名字段，在组合的时候，将所有的字段给了结构体</span></span><br><span class="line">  p.Sex = <span class="hljs-string">'m'</span></span><br><span class="line">  p.human.Sex = <span class="hljs-string">'f'</span> <span class="hljs-comment">// 这两种方式都可以访问。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 这里就一个知识点，匿名字段的类型名和字段名称一致。</span></span><br></pre></td></tr></table></figure><p>对于结构体指着的使用，就不在啰嗦了。</p>]]></content>
    
    <summary type="html">
    
      go语言中结构体的使用
1. 结构体的定义格式
在go语言中结果的定义格式如下：

1
2
3


type structName struct {
  filedList
}


列子如下：

1
2
3
4


type Person struct {
  Name string
  age i
    
    </summary>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>2. Go中函数参数传递类型</title>
    <link href="https://fchunbo.github.io/2018/12/10/Go/2.go%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%B1%BB%E5%9E%8B/"/>
    <id>https://fchunbo.github.io/2018/12/10/Go/2.go中的函数参数传递类型/</id>
    <published>2018-12-09T16:00:00.000Z</published>
    <updated>2019-09-03T15:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在<code>Go</code>语言中，函数的参数的传递类型，分为<strong>值传递</strong>和<strong>引用传递</strong>。但本质就只有值传递，引用传递本质传递是数据存储空间的地址值。</p><h1 id="2-值传递和引用传递"><a href="#2-值传递和引用传递" class="headerlink" title="2. 值传递和引用传递"></a>2. 值传递和引用传递</h1><p>Go语言中如下数据类型为<strong>值传递</strong>：</p><ul><li>基本数据类型中int系列、float系列、bool、string、byte</li><li>数组</li><li>结构体</li></ul><p>注意：上述的数据类型，在分配内存的时候，使用的是<code>new</code>函数。</p><p>如下数据类型为<strong>引用传递</strong>：</p><ul><li>map</li><li>切片slice</li><li>管道chan</li><li>interface</li><li>函数类型</li><li>所有数据类型的指针类型</li></ul><p>注意：map、slice、chan在分配内存的时候，使用的是<code>make</code>函数。</p><p>也就是说：值类型的内存空间使用new来分配，引用数据类型的空间使用的是make来分配。</p><h1 id="3-值传递和引用传递的特点"><a href="#3-值传递和引用传递的特点" class="headerlink" title="3. 值传递和引用传递的特点"></a>3. 值传递和引用传递的特点</h1><p>值传递和引用传递的特点如下：</p><ul><li>值类型默认是值传递，变量直接存储值，内存通常在占中分配</li><li>引用数据类型默认是引用传递，变量存储的是一个地址值，这个地址对应的空间才为存储数据的地址。内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的空间就成为一个垃圾，由GC来回收。</li></ul>]]></content>
    
    <summary type="html">
    
      1. 概述
在Go语言中，函数的参数的传递类型，分为值传递和引用传递。但本质就只有值传递，引用传递本质传递是数据存储空间的地址值。

2. 值传递和引用传递
Go语言中如下数据类型为值传递：

 * 基本数据类型中int系列、float系列、bool、string、byte
 * 数组
 * 结构体
    
    </summary>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>3. Go 中的init函数</title>
    <link href="https://fchunbo.github.io/2018/12/10/Go/3.go%E4%B8%AD%E7%9A%84init%E5%87%BD%E6%95%B0/"/>
    <id>https://fchunbo.github.io/2018/12/10/Go/3.go中的init函数/</id>
    <published>2018-12-09T16:00:00.000Z</published>
    <updated>2019-09-03T15:14:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>每一个源文件都可以有一个<code>init</code>函数，这个函数会在main函数运行之前，被Go框架所调用。</p><h1 id="2-init-函数的特征"><a href="#2-init-函数的特征" class="headerlink" title="2. init 函数的特征"></a>2. init 函数的特征</h1><ul><li><p>init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等</p></li><li><p>每个包可以拥有多个init函数</p></li><li><p>包的每个源文件也可以拥有多个init函数</p></li><li><p>同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)</p></li><li><p>不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序</p></li><li><p>init函数不能被其他函数调用，而是在main函数执行之前，自动被调用</p></li></ul><h1 id="3-init函数的注意事项和细节"><a href="#3-init函数的注意事项和细节" class="headerlink" title="3. init函数的注意事项和细节"></a>3. init函数的注意事项和细节</h1><ul><li><p>如果一个文件同时包含全局变量的定义，init函数，main函数和全局变量的定义的执行流程：</p><p><img src="/images/init.png" alt="init"></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[全局变量定义] --&gt; B(init 函数)</span><br><span class="line">B --&gt; C(main函数)</span><br></pre></td></tr></table></figure></li><li><p><code>init</code>函数最主要的作用就是完成初始化工作</p></li></ul><p>例子：</p><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * @Author fchunbo</span></span><br><span class="line"><span class="hljs-comment"> * @Date 2018-12-10 19:19</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line">    <span class="hljs-string">"fmt"</span></span><br><span class="line">    <span class="hljs-string">"ideaProject/initDemo/util"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 先执行变量定义</span></span><br><span class="line"><span class="hljs-keyword">var</span> age = test()</span><br><span class="line"><span class="hljs-keyword">var</span> name <span class="hljs-keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="hljs-string">"test ..."</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 再执行init函数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    name = <span class="hljs-string">"Jery"</span></span><br><span class="line">    fmt.Println(<span class="hljs-string">"main age init ....."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 最后执行main函数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="hljs-string">"do main.... "</span>)</span><br><span class="line">    fmt.Println(<span class="hljs-string">"Age = "</span>, util.Age, <span class="hljs-string">", Name = "</span>, util.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      1. 概述
每一个源文件都可以有一个init函数，这个函数会在main函数运行之前，被Go框架所调用。

2. init 函数的特征
 * init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等
   
   
 * 每个包可以拥有多个init函数
   
   
 * 包的每个源文
    
    </summary>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://fchunbo.github.io/tags/Go/"/>
    
  </entry>
  
</feed>
