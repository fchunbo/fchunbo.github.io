{"pages":[{"title":"About","text":"this is a post","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"1. Go 错误处理","text":"1. 错误的处理Go 程序使用 error 值来表示错误状态。 与 fmt.Stringer 类似，error 类型是一个内建接口： 123type error interface { Error() string} （与 fmt.Stringer 类似，fmt 包在输出时也会试图匹配 error。） 通常函数会返回一个 error 值，调用的它的代码应当判断这个错误是否等于 nil， 来进行错误处理。 12345i, err := strconv.Atoi(\"42\")if err != nil { fmt.Printf(\"couldn't convert number: %v\\n\", err)}fmt.Println(\"Converted integer:\", i) error 为 nil 时表示成功；非 nil 的 error 表示错误 注意：上述简介说明了，接口类型的变量，零值为nil。这里说了，一般处理错误的方式为，判断返回的err是否为nil，如果err不为nil，表示有错误发生，否则表示没有错误 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * * @Author fchunbo * @Date 2018/12/3 上午11:07 */package mainimport ( \"fmt\" \"time\")// 定义结构体type Myerror struct { When time.Time // 定义结构体时不需要逗号 What string}// 实现Error方法， 隐藏接口为： fmt包中的error接口// 此时 *Myerror类型，就实现了error接口，实质// 就是为error方法设置方法的接收者。func (e *Myerror) Error() string { return fmt.Sprintf(\"at %v， %s\", e.When, e.What)}func run() error { return &amp;Myerror{ time.Now(), \"It didn't work\", }}// 和fmt.Stringer接口类似，fmt输出时会去匹配error接口的Error方法。// 也就是说，当类型实现了error接口的Error方法时，在输出时会自动// 调用类型的Error方法，输出Error方法返回的值。func main() { if err := run(); err != nil { fmt.Println(err) // fmt中的打印函数，会自动匹配Error方法和String()方法 }}","link":"/2019/08/12/Go/1. go_错误处理/"},{"title":"2. Go中函数参数传递类型","text":"1. 概述在Go语言中，函数的参数的传递类型，分为值传递和引用传递。但本质就只有值传递，引用传递本质传递是数据存储空间的地址值。 2. 值传递和引用传递Go语言中如下数据类型为值传递： 基本数据类型中int系列、float系列、bool、string、byte 数组 结构体 注意：上述的数据类型，在分配内存的时候，使用的是new函数。 如下数据类型为引用传递： map 切片slice 管道chan interface 函数类型 所有数据类型的指针类型 注意：map、slice、chan在分配内存的时候，使用的是make函数。 也就是说：值类型的内存空间使用new来分配，引用数据类型的空间使用的是make来分配。 3. 值传递和引用传递的特点值传递和引用传递的特点如下： 值类型默认是值传递，变量直接存储值，内存通常在占中分配 引用数据类型默认是引用传递，变量存储的是一个地址值，这个地址对应的空间才为存储数据的地址。内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的空间就成为一个垃圾，由GC来回收。","link":"/2018/12/10/Go/2.go中的函数参数传递类型/"},{"title":"3. Go 中的init函数","text":"1. 概述每一个源文件都可以有一个init函数，这个函数会在main函数运行之前，被Go框架所调用。 2. init 函数的特征 init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等 每个包可以拥有多个init函数 包的每个源文件也可以拥有多个init函数 同一个包中多个init函数的执行顺序go语言没有明确的定义(说明) 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序 init函数不能被其他函数调用，而是在main函数执行之前，自动被调用 3. init函数的注意事项和细节 如果一个文件同时包含全局变量的定义，init函数，main函数和全局变量的定义的执行流程： 123graph LR A[全局变量定义] --&gt; B(init 函数) B --&gt; C(main函数) init函数最主要的作用就是完成初始化工作 例子： 1234567891011121314151617181920212223242526272829303132/** * * @Author fchunbo * @Date 2018-12-10 19:19 */package mainimport ( \"fmt\" \"ideaProject/initDemo/util\")// 先执行变量定义var age = test()var name stringfunc test() int { fmt.Println(\"test ...\") return 0}// 再执行init函数func init() { name = \"Jery\" fmt.Println(\"main age init .....\")}// 最后执行main函数func main() { fmt.Println(\"do main.... \") fmt.Println(\"Age = \", util.Age, \", Name = \", util.Name)}","link":"/2018/12/10/Go/3.go中的init函数/"},{"title":"4. Go 可导出概念的理解","text":"在使用的Go的过程中，发现引入包后，使用其结构体时，不能访问结构体中以小写字母开头的变量。总之在Go中，以首字母的大小写来控制变量或函数的访问。首字母大写，称为可导出，相当于Java中的public关键字；而首字母小写，称之为不可导出，相当于Java中的private/protected.","link":"/2019/08/12/Go/4. Go中可导出的概念的理解/"},{"title":"5. Go 闭包","text":"函数的闭包在GO语言中，是支持函数的闭包的，具体用法如下例子： 123456789101112131415161718func main() { f := liner(10) fmt.Println(f(1)) fmt.Println(f(2))}/** * 这是一个闭包的例子 */func liner(x int) func(int) int { fmt.Printf(\"%v\\n\", &amp;x) return func (y int) int { fmt.Printf(\"%v\\n\", &amp;x) return x + y }} 结果为： 123450xc0000620080xc000062008110xc00006200812 对于闭包，自己的理解就是：在函数中的匿名函数，使用了外部函数的变量。外部函数调用之后，返回的函数，在使用过程中，外部函数的变量一直未被销毁，感觉上就像是外部函数的变量，一直被内部的匿名函数给”包裹”，始终拥有外部函数变量的引用。 从打印结果看，外部变量的地址和匿名函数调用时，使用的x是同一变量。 注意: 在循环中使用defer 123456789import \"fmt\"func main() { for i := 0; i &lt; 3; i ++ { defer func() { fmt.Println(i) }() }} 这段代码的原本的想要的结果为：0 1 2 但是上述代码执行的结果为: 123333 为什么会这样呢？其实这也是闭包的使用，在defer函数使用i其实是对变量i的引用，当循环结果后，i的值为3，既然defer修饰的函数是对变量i的引用，所以所有的defer函数都打印出了3. 所以，在使用defer修饰的匿名函数时，一定要注意，慎重使用所在函数的变量。 为了加深印象, 打印如下代码的结果： 1234567891011121314151617181920func main() { var fs = [4]func(){} for i := 0; i &lt; 4; i++ { defer fmt.Println(\"defer i = \", i) // 这也是闭包 defer func(){ fmt.Println(\"defer_closure i = \", i)// 保存了i的引用 }() // 这也是闭包，这里只是保存了i变量的引用 fs[i] = func() { fmt.Println(\"closure i = \", i) } } for _, f := range fs { f() }} 结果为： 123456789101112closure i = 4closure i = 4closure i = 4closure i = 4defer_closure i = 4defer i = 3defer_closure i = 4defer i = 2defer_closure i = 4defer i = 1defer_closure i = 4defer i = 0","link":"/2019/03/28/Go/5.函数闭包的使用以及注意/"},{"title":"6. Go 语言中结构体的使用","text":"go语言中结构体的使用1. 结构体的定义格式在go语言中结果的定义格式如下： 123type structName struct { filedList} 列子如下： 1234type Person struct { Name string age int} 对上上述这种方式定义的结构体有如下几种初始化的方式 默认的方式， 这种方式也是零值初始化方式 1p := Person{} 使用字面量进行初始化 12p := Person{\"Joe\", 19} // 注意此时必须按照顺序初始化pp := Person{age: 19, Name: \"Joe\"} // 指定fieldname方式赋值，不用按照顺序 2. 匿名结构体的使用对于匿名结构体，可以在初始化变量的时定义，如下： 1234567891011121314func main() { user := struct { Name string Age int } {Name: \"joe\", Age: 19 } fmt.Println(user)}或user := struct { Name string Age int }{\"jor\", 10} 同样在定义结构体时，也可以使用匿名结构体, 如下： 12345678type User struct { Name string Age int Content struct { // 匿名结构体 Tel string Email string }} 对于在结构体中的匿名结构体，在初始化的时候，需要如下操作： 1234567func main(){ user := {Name: \"joe\", Age: 10} // 对于结构体中的匿名结构体只能这样初始化 user.Content.Tel = \"12306\" user.Content.Email = \"214639811@qq.com\"} 注意：在GO中结构体，就是某些字段的集合，是值类型的，可以进行 ==比较的，注意必须是相同类型的结构体。 3. 结构体中的匿名字段结构体中的匿名字段，可以是GO语言内置的，也可以是自定义的类型。GO内置的类型，例子如下: 1234type Person struct{ string int} 对于这种结构体，必须按照顺序进行初始化。 1234func main() { p := Person{\"joe\", 10} fmt.Println(p)} 在go中没有继承机制，自定义类型的匿名字段在go中叫做组合继承，如下 123456789type human struct{ Sex string}type Person struct{ human // 注意：匿名字段，类型名和字段名是一致的 Name string Age int} 对于这种结构体的初始化，按照顺序初始化，如下 1234func main() { p := Person{human{Sex: \"f\"}, \"joe\", 20} fmt.Println(p)} 指定字段名进行初始化 123456789func main() { p := Person{Name: \"joe\", Age: 10, human: human{Sex: \"f\"}} p := Person{Name: \"joe\", Age: 10, human: human{Sex: \"f\"}} // 注意： 对于结构体中的匿名字段，在组合的时候，将所有的字段给了结构体 p.Sex = 'm' p.human.Sex = 'f' // 这两种方式都可以访问。}// 这里就一个知识点，匿名字段的类型名和字段名称一致。 对于结构体指着的使用，就不在啰嗦了。","link":"/2019/03/28/Go/6.struct/"},{"title":"7. Go 中接口的理解","text":"接口的理解在Go中的接口就是一些方法的集合，在接口只能定义方法，不能像Java那样还能定义一些常量。并且在Go中接口的实现方式，采用的是Duck Type，只要某个结构具有接口的方法，那么就实现了接口。Go中的接口，是隐式实现的，不必显示的声明。例如： 1234567891011// http handler 接口type Handler interface { ServeHTTP(w http.ResponseWriter, r *http.Request)}// 实现该接口type MyHandler struct {}func (h MyHandler) ServeHTTP(w http.ResponseWrite, r *http.Request) { fmt.Fprintln(w, \"Hello World\")} 此时，就可以说，MyHandler就实现了http.Handler接口。在Go语言中接口的实现，可以理解为：像什么就是什么。 注意： 1将对象赋值给接口变量时，会发生拷贝，就像函数或方法传参一样，是值拷贝。在接口变量内部存储的是指向这个复制品的指针，即无法修改复制品的状态，也无法获取指针。 也就说，将对象赋值给接口变量后，对象中的字段改变，不会反映到接口变量指向的复制品中。例子如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * * @Author fchunbo * @Date 2019-03-31 17:35 */package mainimport \"fmt\"type USB interface { Name() string Connect()}type PhoneConnector struct { name string}// 注意：和函数是可以转换的// 并且，对于类型的方法，接收者强制为方法的第一个参数。func (pc PhoneConnector) Name() string { return pc.name}func (pc PhoneConnector) Connect() { fmt.Println(\"Connected: \", pc.name)}func main() { var usb USB var pc PhoneConnector = PhoneConnector{\"iPhone\"} usb = pc // 注意这里发生了值拷贝，usb内存存储了指向复制品的指针。 usb.Connect() // iPhone pc.name = \"andriod\" usb.Connect() // iPhone}","link":"/2019/03/31/Go/7.接口的理解/"},{"title":"8. Go Channel的使用","text":"Go Channel在Go中，多个goroutines推荐使用channel来进行通信。使用channel来共享内存。 go中channel有三种类型：读写channel, 只读channel，只写的channel 默认为读写的channel： 1c := make(chan int) 同时channel还可以有缓存。定义如下： 1c := make(chan int, 2) 上述定义了带有2个元素缓存的，channel 一般只读或只写的channel，大多出现在函数传参中，当然也可以直接定义： 12c1 := make(&lt;-chan int) // 定义了一个只读的channelc2 := make(chan &lt;-int) // 定义了一个只写的channel 注意： 对于缓存的channel，写数据也是阻塞的，直到将channel中的数据读出；读也是阻塞的，直到channel中有数据可读 123456789func main() { c := make(chan bool) go func() { fmt.Println(\"Go GO Go !!\") c &lt;- true }() &lt;- c // 等待读取数据，} 对于带缓存的channel，在使用时，一定要注意如下情况： 123456789101112131415161718// 下面这种情况，需要注意，channel是否有缓存// 否则在实际的开发中，很有可能goroutines还没有执行// 程序就结束了。func main() { //c := make(chan bool, 1) c := make(chan bool) go func() { fmt.Println(\"Go GO Go !!\") &lt;- c }() // 对于无缓存时，如果没有读取channle中的数据，写也是阻塞的,必须将数据 // 读取了之后，才能退出 // 对于有缓存的channel，我把数据写进去就是，不管你是否读取。 c &lt;- true} 判断channel是否关闭判断channnel是否关闭，是在接收channel的数据时候，判断的： 1v, ok := &lt;-c // 如果channel关闭了，ok = false 特别在for range循环遍历channel时，必须使用Close()函数关闭channnel，表示结束数据的写入，同时for循环也终止。","link":"/2019/04/03/Go/8.Channel/"},{"title":"9. Go 内存模型","text":"暂时未研究","link":"/2019/04/21/Go/9.Go语言的内存模型/"},{"title":"Go Module的简单使用","text":"Go Module的简单使用1. 打开Go Module1export GO111MODULE=on[off|auto] on 表示仅使用Go Modules模式来管理go的依赖 off 表示关闭Go Modules模式，使用GOPATH auto 表示如果在GOPATH下，就使用GOPATH；同时也可以使用GO Modules模式 2. 设置代理1export GOPROXY=https://goproxy.io 这样设置之后，可以下载google相关的包。 3. 使用1go mod init 模块名 使用上述命令，就可以初始化一个模块。","link":"/2019/08/12/Go/go module/1. 如何简单的使用go mod来进行包管理/"},{"title":"go语言提供的静态服务器","text":"go语言提供的静态服务器在go语言中，默认提供了静态的文件服务器，使用方法如下 123456789101112131415161718192021222324252627282930313233343536373839404142/** * * @Author fchunbo * @Date 2019-03-18 13:42 */package mainimport ( \"fmt\" \"log\" \"net/http\" \"os\")func sayHello(w http.ResponseWriter, r *http.Request) { r.ParseForm() // 解析参数，默认是不会解析的 fmt.Println(r.Form) fmt.Println(\"path： \", r.URL.Path) fmt.Println(\"schema: \", r.URL.Scheme) fmt.Println(r.Form[\"url_long\"]) for k, v := range r.Form { fmt.Println(\"key:\", k) fmt.Println(\"value: \", v) } // 给客户端返回结果 fmt.Fprintln(w, \"hello rob\")}func main() { http.HandleFunc(\"/\", sayHello) wd, _ := os.Getwd() http.Handle(\"/static/\", http.StripPrefix(\"/static/\", http.FileServer(http.Dir(wd)))) err := http.ListenAndServe(\":8080\", nil) if err != nil { log.Fatal(\"ListenServer:\", err) }} 注意：Go语言提供的静态文件服务器是基于绝对路径的，因此需要使用os.Getwd，来回去程序的路径。 用法： 1http.Handle(\"/static/\", http.StripPrefix(\"/static/\", http.FileServer(http.Dir(wd))))","link":"/2019/07/22/Go/package/http/go语言提供的静态服务器/"},{"title":"http包中serverHandler类型的分析","text":"http包中serverHandler类型的分析12345678910111213141516// serverHandler delegates to either the server's Handler or// DefaultServeMux and also handles \"OPTIONS *\" requests.type serverHandler struct { srv *Server}func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) { handler := sh.srv.Handler if handler == nil { handler = DefaultServeMux } if req.RequestURI == \"*\" &amp;&amp; req.Method == \"OPTIONS\" { handler = globalOptionsHandler{} } handler.ServeHTTP(rw, req)} serverHandler是一个结构体，在结构体中，只有一个字段sv *Server, 这里在实际运行的过程中，保存了最开始创建的Server实例，包好了服务端Ip端口信息，Handler信息等。 serverHandler也实现了http.Handler接口，我们看一下其ServeHTTP方法的实现： 1handler := sh.srv.Handler 这里是在获取Server实例中的Handler对象，也就是在调用http.ListenAndServe函数，传入的Handler。 123if handler == nil { handler = DefaultServeMux} 这里判断handler如果为空，就使用默认的handler，ServeMux。 1handler.ServeHTTP(rw, req) 这里就调用handler的ServeHTTP方法了，要么进入到自定义的handler中，要么进入到ServeMuxhandler中。 接下来我们，我们看一下serverHandler的使用的地方。其实serverHandler是在接收到客户端的请求后，调用Conn的serve方法中使用的。 1go c.serve(ctx) // 使用goroutines处理我们的请求 Conn的server方法如下： 12345678910111213141516171819202122232425262728293031// Serve a new connection.func (c *conn) serve(ctx context.Context) { c.remoteAddr = c.rwc.RemoteAddr().String() ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr()) defer func() { if err := recover(); err != nil &amp;&amp; err != ErrAbortHandler { const size = 64 &lt;&lt; 10 buf := make([]byte, size) buf = buf[:runtime.Stack(buf, false)] c.server.logf(\"http: panic serving %v: %v\\n%s\", c.remoteAddr, err, buf) } if !c.hijacked() { c.close() c.setState(c.rwc, StateClosed) } }() .....// 省略 // HTTP cannot have multiple simultaneous active requests.[*] // Until the server replies to this request, it can't read another, // so we might as well run the handler in this goroutine. // [*] Not strictly true: HTTP pipelining. We could let them all process // in parallel even if their responses need to be serialized. // But we're not going to implement HTTP pipelining because it // was never deployed in the wild and the answer is HTTP/2. // 内部的serverHandler结构体，获取Server对象，创建 // serverHandler实例，并调用ServerHTTP方法 serverHandler{c.server}.ServeHTTP(w, w.req) .....} 从这个代码中，可以看出，serverHandler起到了承上启下的作用，由于路由到了我们自定义的handler或ServeMux Handler中， 从而路由到我们的实现的Handler函数。","link":"/2019/04/19/Go/package/http/serverHander的分析/"},{"title":"Go Http包WebServer运行的整个流程与原理","text":"Http包WebServer运行的整个流程与原理讲解GO web server运行流程，使用如下例子来讲解。进行源码分析 123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\" \"log\" \"net/http\")func sayHello(w http.ResponseWriter, r *http.Request) { r.ParseForm() // 解析参数，默认是不会解析的 fmt.Println(r.Form) fmt.Println(\"path： \", r.URL.Path) fmt.Println(\"schema: \", r.URL.Scheme) fmt.Println(r.Form[\"url_long\"]) for k, v := range r.Form { fmt.Println(\"key:\", k) fmt.Println(\"value: \", v) } // 给客户端返回结果 fmt.Fprintln(w, \"hello rob\")}func main() { http.HandleFunc(\"/\", sayHello) err := http.ListenAndServe(\":8080\", nil) if err != nil { log.Fatal(\"ListenServer:\", err) }} 上述程序就构成了一个简单的web server，是如何运行的呢？就从main函数开始讲解。 Handler函数的注册首先注册我们handler函数 1http.HandleFunc(\"/\", sayHello) http.HandleFunc函数的源码如下： 123func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { DefaultServeMux.HandleFunc(pattern, handler)} 可以看到，http.HandleFunc函数的实质是DefaultServeMux的HandleFunc方法，那么DefaultServeMux的定义为： 1234// DefaultServeMux is the default ServeMux used by Serve.var DefaultServeMux = &amp;defaultServeMuxvar defaultServeMux ServeMux 可以看出DefaultServeMux就是ServeMUX 指针类型。ServeMux的作用就是起到了默认的路由器的作用。定义如下： 12345type ServeMux struct { mu sync.RWMutex m map[string]muxEntry hosts bool // whether any patterns contain hostnames} 其HandleFunc方法如下： 1234567891011121314151617181920212223242526272829303132333435// HandleFunc registers the handler function for the given pattern.func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { if handler == nil { panic(\"http: nil handler\") } // 这里调用了自身的Handle方法, HandlerFunc 函数类型 mux.Handle(pattern, HandlerFunc(handler))}// Handle registers the handler for the given pattern.// If a handler already exists for pattern, Handle panics.func (mux *ServeMux) Handle(pattern string, handler Handler) { mux.mu.Lock() defer mux.mu.Unlock() if pattern == \"\" { panic(\"http: invalid pattern\") } if handler == nil { panic(\"http: nil handler\") } if _, exist := mux.m[pattern]; exist { panic(\"http: multiple registrations for \" + pattern) } if mux.m == nil { mux.m = make(map[string]muxEntry) } mux.m[pattern] = muxEntry{h: handler, pattern: pattern} if pattern[0] != '/' { mux.hosts = true }} 注意：在改方法中，handler就是sayHello函数.mux.Handle(pattern, HandlerFunc(handler))中，HandlerFunc(handler) 是一个强制类型转换语句，HandlerFunc其实一个函数类型，实现了Handler接口。定义如下： 1234567type HandlerFunc func(ResponseWriter, *Request)// ServeHTTP calls f(w, r). func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) // 调用HandlerFunc类型自身。} 从源码中可以看出，HandlerFunc类型实现了http.Handler接口的ServeHTTP函数，也就说HandlerFunc也就是http.Handler类型。其中的 ServeMux的Handle方法，就实现了URI和Handler的映射。 请求是如何到达后端的处理函数说明请求是如何到达后端函数，从如下语句说起： 1err := http.ListenAndServe(\":8080\", nil) http.ListenAndServe函数，设置Web Server的端口，并监听客户端的请求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091func ListenAndServe(addr string, handler Handler) error { // 创建server，我们设置的handler为nil，相当于默认使用ServeMux去处理 server := &amp;Server{Addr: addr, Handler: handler} // 调用了Server的ListenAndServe()方法 return server.ListenAndServe()}// Server的ListenAndServe()方法的源码如下：func (srv *Server) ListenAndServe() error { if srv.shuttingDown() { return ErrServerClosed } addr := srv.Addr if addr == \"\" { addr = \":http\" } // 调用net包中的Listen函数，监听网络 ln, err := net.Listen(\"tcp\", addr) if err != nil { return err } return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})}// Server 的Serve方法的源码如下func (srv *Server) Serve(l net.Listener) error { if fn := testHookServerServe; fn != nil { fn(srv, l) // call hook with unwrapped listener } l = &amp;onceCloseListener{Listener: l} defer l.Close() if err := srv.setupHTTP2_Serve(); err != nil { return err } if !srv.trackListener(&amp;l, true) { return ErrServerClosed } defer srv.trackListener(&amp;l, false) var tempDelay time.Duration // how long to sleep on accept failure baseCtx := context.Background() // base is always background, per Issue 16220 ctx := context.WithValue(baseCtx, ServerContextKey, srv) for { rw, e := l.Accept() // 阻塞监听客户端的连接 if e != nil { select { case &lt;-srv.getDoneChan(): return ErrServerClosed default: } if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() { if tempDelay == 0 { tempDelay = 5 * time.Millisecond } else { tempDelay *= 2 } if max := 1 * time.Second; tempDelay &gt; max { tempDelay = max } srv.logf(\"http: Accept error: %v; retrying in %v\", e, tempDelay) time.Sleep(tempDelay) continue } return e } tempDelay = 0 // 这里表示，有客户端的请求进来 // 调用Server的newConn方法，获取到一个连接 c := srv.newConn(rw) c.setState(c.rwc, StateNew) // before Serve can return go c.serve(ctx) // 使用goroutines处理我们的请求 }}// Create new connection from rwc.func (srv *Server) newConn(rwc net.Conn) *conn { c := &amp;conn{ server: srv, // 将Server实例传入，初始化conn rwc: rwc, } if debugServerConnections { c.rwc = newLoggingConn(\"server\", c.rwc) } return c} 注意: c 为conn实例，代表HTTP Server端的一个连接，内部封装Server对象信息。 c.serve(ctx)语句就是处理用户请求，其源码如下： 12345678910111213141516171819202122232425262728293031// Serve a new connection.func (c *conn) serve(ctx context.Context) { c.remoteAddr = c.rwc.RemoteAddr().String() ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr()) defer func() { if err := recover(); err != nil &amp;&amp; err != ErrAbortHandler { const size = 64 &lt;&lt; 10 buf := make([]byte, size) buf = buf[:runtime.Stack(buf, false)] c.server.logf(\"http: panic serving %v: %v\\n%s\", c.remoteAddr, err, buf) } if !c.hijacked() { c.close() c.setState(c.rwc, StateClosed) } }() .....// 省略 // HTTP cannot have multiple simultaneous active requests.[*] // Until the server replies to this request, it can't read another, // so we might as well run the handler in this goroutine. // [*] Not strictly true: HTTP pipelining. We could let them all process // in parallel even if their responses need to be serialized. // But we're not going to implement HTTP pipelining because it // was never deployed in the wild and the answer is HTTP/2. // 内部的serverHandler结构体，获取Server对象，创建 // serverHandler实例，并调用ServerHTTP方法 serverHandler{c.server}.ServeHTTP(w, w.req) .....} serverHandler结构体的ServeHTTP方法如下： 123456789101112131415161718192021// serverHandler delegates to either the server's Handler or// DefaultServeMux and also handles \"OPTIONS *\" requests.type serverHandler struct { srv *Server}func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) { // 首先去获取Server的Handler，我们初始化的时候为nil，从这里可以看出 // 我们可以实现Handler来接管默认的路由器 handler := sh.srv.Handler if handler == nil { // 如果handler为nil， 就使用DefaultServeMux,也就是默认的路由器 handler = DefaultServeMux } if req.RequestURI == \"*\" &amp;&amp; req.Method == \"OPTIONS\" { handler = globalOptionsHandler{} } // 调用ServerMux的ServeHTTP方法， 实现路由 handler.ServeHTTP(rw, req)} ServerMux的ServeHTTP方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// ServeHTTP dispatches the request to the handler whose// pattern most closely matches the request URL.func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) { if r.RequestURI == \"*\" { if r.ProtoAtLeast(1, 1) { w.Header().Set(\"Connection\", \"close\") } w.WriteHeader(StatusBadRequest) return } // 根据request的URI获取对应的Handler，这里就是我们的HandlerFunc类型的handler h, _ := mux.Handler(r) h.ServeHTTP(w, r)}func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) { // CONNECT requests are not canonicalized. if r.Method == \"CONNECT\" { // If r.URL.Path is /tree and its handler is not registered, // the /tree -&gt; /tree/ redirect applies to CONNECT requests // but the path canonicalization does not. if u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok { return RedirectHandler(u.String(), StatusMovedPermanently), u.Path } return mux.handler(r.Host, r.URL.Path) } // All other requests have any port stripped and path cleaned // before passing to mux.handler. host := stripHostPort(r.Host) path := cleanPath(r.URL.Path) // If the given path is /tree and its handler is not registered, // redirect for /tree/. if u, ok := mux.redirectToPathSlash(host, path, r.URL); ok { return RedirectHandler(u.String(), StatusMovedPermanently), u.Path } if path != r.URL.Path { _, pattern = mux.handler(host, path) url := *r.URL url.Path = path return RedirectHandler(url.String(), StatusMovedPermanently), pattern } return mux.handler(host, r.URL.Path)}func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) { mux.mu.RLock() defer mux.mu.RUnlock() // Host-specific pattern takes precedence over generic ones if mux.hosts { h, pattern = mux.match(host + path) } if h == nil { h, pattern = mux.match(path) } if h == nil { h, pattern = NotFoundHandler(), \"\" } return} 当获取到HandlerFunc类型Handler时，就会调用去调用自己，HandlerFunc的ServeHTTP方法如下： 1234// ServeHTTP calls f(w, r).func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) // 调用自己，也就是我们注册的后台处理方法。在这个例子中就是调用sayhello函数} Go 代码执行流程通过对http包的分析之后，现在让我们来梳理一下整个的代码执行过程。首先调用Http.HandleFunc按顺序做了几件事： 调用了DefaultServeMux的HandleFunc 调用了DefaultServeMux的Handle 往DefaultServeMux的map[string]muxEntry中增加对应的handler和路由规则 其次调用http.ListenAndServe(“:9090”, nil)， 按顺序做了几件事情: 实例化Server 调用Server的ListenAndServe() 调用net.Listen(“tcp”, addr)监听端口 启动一个for循环，在循环体中Accept请求 对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve() 读取每个请求的内容w, err := c.readRequest() 判断handler是否为空，如果没有设置handler（ 这个例子就没有设置handler） ，handler就设置为DefaultServeMux 调用handler的ServeHttp 在这个例子中，下面就进入到DefaultServeMux.ServeHttp 根据request选择handler，并且进入到这个handler的ServeHTTP 1mux.handler(r).ServeHTTP(w, r) 选择handler：A 判断是否有路由能满足这个request（ 循环遍历ServeMux的muxEntry）B 如果有路由满足，调用这个路由handler的ServeHTTPC 如果没有路由满足，调用NotFoundHandler的ServeHTTP","link":"/2019/07/22/Go/package/http/Go http包web server的原理/"}],"tags":[{"name":"Go","slug":"Go","link":"/tags/Go/"}],"categories":[{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"http","slug":"Go/http","link":"/categories/Go/http/"}]}