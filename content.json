{"pages":[{"title":"About","text":"this is a post","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"1. Go 错误处理","text":"1. 错误的处理Go 程序使用 error 值来表示错误状态。 与 fmt.Stringer 类似，error 类型是一个内建接口： 123type error interface { Error() string} （与 fmt.Stringer 类似，fmt 包在输出时也会试图匹配 error。） 通常函数会返回一个 error 值，调用的它的代码应当判断这个错误是否等于 nil， 来进行错误处理。 12345i, err := strconv.Atoi(\"42\")if err != nil { fmt.Printf(\"couldn't convert number: %v\\n\", err)}fmt.Println(\"Converted integer:\", i) error 为 nil 时表示成功；非 nil 的 error 表示错误 注意：上述简介说明了，接口类型的变量，零值为nil。这里说了，一般处理错误的方式为，判断返回的err是否为nil，如果err不为nil，表示有错误发生，否则表示没有错误 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * * @Author fchunbo * @Date 2018/12/3 上午11:07 */package mainimport ( \"fmt\" \"time\")// 定义结构体type Myerror struct { When time.Time // 定义结构体时不需要逗号 What string}// 实现Error方法， 隐藏接口为： fmt包中的error接口// 此时 *Myerror类型，就实现了error接口，实质// 就是为error方法设置方法的接收者。func (e *Myerror) Error() string { return fmt.Sprintf(\"at %v， %s\", e.When, e.What)}func run() error { return &amp;Myerror{ time.Now(), \"It didn't work\", }}// 和fmt.Stringer接口类似，fmt输出时会去匹配error接口的Error方法。// 也就是说，当类型实现了error接口的Error方法时，在输出时会自动// 调用类型的Error方法，输出Error方法返回的值。func main() { if err := run(); err != nil { fmt.Println(err) // fmt中的打印函数，会自动匹配Error方法和String()方法 }}","link":"/2019/08/12/Go/1. go_错误处理/"},{"title":"2. Go中函数参数传递类型","text":"1. 概述在Go语言中，函数的参数的传递类型，分为值传递和引用传递。但本质就只有值传递，引用传递本质传递是数据存储空间的地址值。 2. 值传递和引用传递Go语言中如下数据类型为值传递： 基本数据类型中int系列、float系列、bool、string、byte 数组 结构体 注意：上述的数据类型，在分配内存的时候，使用的是new函数。 如下数据类型为引用传递： map 切片slice 管道chan interface 函数类型 所有数据类型的指针类型 注意：map、slice、chan在分配内存的时候，使用的是make函数。 也就是说：值类型的内存空间使用new来分配，引用数据类型的空间使用的是make来分配。 3. 值传递和引用传递的特点值传递和引用传递的特点如下： 值类型默认是值传递，变量直接存储值，内存通常在占中分配 引用数据类型默认是引用传递，变量存储的是一个地址值，这个地址对应的空间才为存储数据的地址。内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的空间就成为一个垃圾，由GC来回收。","link":"/2018/12/10/Go/2.go中的函数参数传递类型/"},{"title":"3. Go 中的init函数","text":"1. 概述每一个源文件都可以有一个init函数，这个函数会在main函数运行之前，被Go框架所调用。 2. init 函数的特征 init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等 每个包可以拥有多个init函数 包的每个源文件也可以拥有多个init函数 同一个包中多个init函数的执行顺序go语言没有明确的定义(说明) 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序 init函数不能被其他函数调用，而是在main函数执行之前，自动被调用 3. init函数的注意事项和细节 如果一个文件同时包含全局变量的定义，init函数，main函数和全局变量的定义的执行流程： 123graph LR A[全局变量定义] --&gt; B(init 函数) B --&gt; C(main函数) init函数最主要的作用就是完成初始化工作 例子： 1234567891011121314151617181920212223242526272829303132/** * * @Author fchunbo * @Date 2018-12-10 19:19 */package mainimport ( \"fmt\" \"ideaProject/initDemo/util\")// 先执行变量定义var age = test()var name stringfunc test() int { fmt.Println(\"test ...\") return 0}// 再执行init函数func init() { name = \"Jery\" fmt.Println(\"main age init .....\")}// 最后执行main函数func main() { fmt.Println(\"do main.... \") fmt.Println(\"Age = \", util.Age, \", Name = \", util.Name)}","link":"/2018/12/10/Go/3.go中的init函数/"},{"title":"4. Go 可导出概念的理解","text":"在使用的Go的过程中，发现引入包后，使用其结构体时，不能访问结构体中以小写字母开头的变量。总之在Go中，以首字母的大小写来控制变量或函数的访问。首字母大写，称为可导出，相当于Java中的public关键字；而首字母小写，称之为不可导出，相当于Java中的private/protected.","link":"/2019/08/12/Go/4. Go中可导出的概念的理解/"},{"title":"5. Go 闭包","text":"函数的闭包在GO语言中，是支持函数的闭包的，具体用法如下例子： 123456789101112131415161718func main() { f := liner(10) fmt.Println(f(1)) fmt.Println(f(2))}/** * 这是一个闭包的例子 */func liner(x int) func(int) int { fmt.Printf(\"%v\\n\", &amp;x) return func (y int) int { fmt.Printf(\"%v\\n\", &amp;x) return x + y }} 结果为： 123450xc0000620080xc000062008110xc00006200812 对于闭包，自己的理解就是：在函数中的匿名函数，使用了外部函数的变量。外部函数调用之后，返回的函数，在使用过程中，外部函数的变量一直未被销毁，感觉上就像是外部函数的变量，一直被内部的匿名函数给”包裹”，始终拥有外部函数变量的引用。 从打印结果看，外部变量的地址和匿名函数调用时，使用的x是同一变量。 注意: 在循环中使用defer 123456789import \"fmt\"func main() { for i := 0; i &lt; 3; i ++ { defer func() { fmt.Println(i) }() }} 这段代码的原本的想要的结果为：0 1 2 但是上述代码执行的结果为: 123333 为什么会这样呢？其实这也是闭包的使用，在defer函数使用i其实是对变量i的引用，当循环结果后，i的值为3，既然defer修饰的函数是对变量i的引用，所以所有的defer函数都打印出了3. 所以，在使用defer修饰的匿名函数时，一定要注意，慎重使用所在函数的变量。 为了加深印象, 打印如下代码的结果： 1234567891011121314151617181920func main() { var fs = [4]func(){} for i := 0; i &lt; 4; i++ { defer fmt.Println(\"defer i = \", i) // 这也是闭包 defer func(){ fmt.Println(\"defer_closure i = \", i)// 保存了i的引用 }() // 这也是闭包，这里只是保存了i变量的引用 fs[i] = func() { fmt.Println(\"closure i = \", i) } } for _, f := range fs { f() }} 结果为： 123456789101112closure i = 4closure i = 4closure i = 4closure i = 4defer_closure i = 4defer i = 3defer_closure i = 4defer i = 2defer_closure i = 4defer i = 1defer_closure i = 4defer i = 0","link":"/2019/03/28/Go/5.函数闭包的使用以及注意/"},{"title":"6. Go 语言中结构体的使用","text":"go语言中结构体的使用1. 结构体的定义格式在go语言中结果的定义格式如下： 123type structName struct { filedList} 列子如下： 1234type Person struct { Name string age int} 对上上述这种方式定义的结构体有如下几种初始化的方式 默认的方式， 这种方式也是零值初始化方式 1p := Person{} 使用字面量进行初始化 12p := Person{\"Joe\", 19} // 注意此时必须按照顺序初始化pp := Person{age: 19, Name: \"Joe\"} // 指定fieldname方式赋值，不用按照顺序 2. 匿名结构体的使用对于匿名结构体，可以在初始化变量的时定义，如下： 1234567891011121314func main() { user := struct { Name string Age int } {Name: \"joe\", Age: 19 } fmt.Println(user)}或user := struct { Name string Age int }{\"jor\", 10} 同样在定义结构体时，也可以使用匿名结构体, 如下： 12345678type User struct { Name string Age int Content struct { // 匿名结构体 Tel string Email string }} 对于在结构体中的匿名结构体，在初始化的时候，需要如下操作： 1234567func main(){ user := {Name: \"joe\", Age: 10} // 对于结构体中的匿名结构体只能这样初始化 user.Content.Tel = \"12306\" user.Content.Email = \"214639811@qq.com\"} 注意：在GO中结构体，就是某些字段的集合，是值类型的，可以进行 ==比较的，注意必须是相同类型的结构体。 3. 结构体中的匿名字段结构体中的匿名字段，可以是GO语言内置的，也可以是自定义的类型。GO内置的类型，例子如下: 1234type Person struct{ string int} 对于这种结构体，必须按照顺序进行初始化。 1234func main() { p := Person{\"joe\", 10} fmt.Println(p)} 在go中没有继承机制，自定义类型的匿名字段在go中叫做组合继承，如下 123456789type human struct{ Sex string}type Person struct{ human // 注意：匿名字段，类型名和字段名是一致的 Name string Age int} 对于这种结构体的初始化，按照顺序初始化，如下 1234func main() { p := Person{human{Sex: \"f\"}, \"joe\", 20} fmt.Println(p)} 指定字段名进行初始化 123456789func main() { p := Person{Name: \"joe\", Age: 10, human: human{Sex: \"f\"}} p := Person{Name: \"joe\", Age: 10, human: human{Sex: \"f\"}} // 注意： 对于结构体中的匿名字段，在组合的时候，将所有的字段给了结构体 p.Sex = 'm' p.human.Sex = 'f' // 这两种方式都可以访问。}// 这里就一个知识点，匿名字段的类型名和字段名称一致。 对于结构体指着的使用，就不在啰嗦了。","link":"/2019/03/28/Go/6.struct/"},{"title":"7. Go 中接口的理解","text":"接口的理解在Go中的接口就是一些方法的集合，在接口只能定义方法，不能像Java那样还能定义一些常量。并且在Go中接口的实现方式，采用的是Duck Type，只要某个结构具有接口的方法，那么就实现了接口。Go中的接口，是隐式实现的，不必显示的声明。例如： 1234567891011// http handler 接口type Handler interface { ServeHTTP(w http.ResponseWriter, r *http.Request)}// 实现该接口type MyHandler struct {}func (h MyHandler) ServeHTTP(w http.ResponseWrite, r *http.Request) { fmt.Fprintln(w, \"Hello World\")} 此时，就可以说，MyHandler就实现了http.Handler接口。在Go语言中接口的实现，可以理解为：像什么就是什么。 注意： 1将对象赋值给接口变量时，会发生拷贝，就像函数或方法传参一样，是值拷贝。在接口变量内部存储的是指向这个复制品的指针，即无法修改复制品的状态，也无法获取指针。 也就说，将对象赋值给接口变量后，对象中的字段改变，不会反映到接口变量指向的复制品中。例子如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * * @Author fchunbo * @Date 2019-03-31 17:35 */package mainimport \"fmt\"type USB interface { Name() string Connect()}type PhoneConnector struct { name string}// 注意：和函数是可以转换的// 并且，对于类型的方法，接收者强制为方法的第一个参数。func (pc PhoneConnector) Name() string { return pc.name}func (pc PhoneConnector) Connect() { fmt.Println(\"Connected: \", pc.name)}func main() { var usb USB var pc PhoneConnector = PhoneConnector{\"iPhone\"} usb = pc // 注意这里发生了值拷贝，usb内存存储了指向复制品的指针。 usb.Connect() // iPhone pc.name = \"andriod\" usb.Connect() // iPhone}","link":"/2019/03/31/Go/7.接口的理解/"},{"title":"8. Go Channel的使用","text":"Go Channel在Go中，多个goroutines推荐使用channel来进行通信。使用channel来共享内存。 go中channel有三种类型：读写channel, 只读channel，只写的channel 默认为读写的channel： 1c := make(chan int) 同时channel还可以有缓存。定义如下： 1c := make(chan int, 2) 上述定义了带有2个元素缓存的，channel 一般只读或只写的channel，大多出现在函数传参中，当然也可以直接定义： 12c1 := make(&lt;-chan int) // 定义了一个只读的channelc2 := make(chan &lt;-int) // 定义了一个只写的channel 注意： 对于缓存的channel，写数据也是阻塞的，直到将channel中的数据读出；读也是阻塞的，直到channel中有数据可读 123456789func main() { c := make(chan bool) go func() { fmt.Println(\"Go GO Go !!\") c &lt;- true }() &lt;- c // 等待读取数据，} 对于带缓存的channel，在使用时，一定要注意如下情况： 123456789101112131415161718// 下面这种情况，需要注意，channel是否有缓存// 否则在实际的开发中，很有可能goroutines还没有执行// 程序就结束了。func main() { //c := make(chan bool, 1) c := make(chan bool) go func() { fmt.Println(\"Go GO Go !!\") &lt;- c }() // 对于无缓存时，如果没有读取channle中的数据，写也是阻塞的,必须将数据 // 读取了之后，才能退出 // 对于有缓存的channel，我把数据写进去就是，不管你是否读取。 c &lt;- true} 判断channel是否关闭判断channnel是否关闭，是在接收channel的数据时候，判断的： 1v, ok := &lt;-c // 如果channel关闭了，ok = false 特别在for range循环遍历channel时，必须使用Close()函数关闭channnel，表示结束数据的写入，同时for循环也终止。","link":"/2019/04/03/Go/8.Channel/"},{"title":"9. Go 内存模型","text":"暂时未研究","link":"/2019/04/21/Go/9.Go语言的内存模型/"},{"title":"Mysql 逻辑架构","text":"1. 逻辑架构 2. 逻辑架构说明连接器（Connectors）也就是mysql的 连接驱动 系统管理和控制工具（Management Serveices &amp; Utilities） 连接池（Connection Pool） SQL Layer MySQL业务层 SQL接口（SQL Interface）接收SQL DML DDL 解析器（Parser）select * from t1 词法分析 分词： 形成成语法树 语法分析 分析 ： 符合SQL的语法 SQL的语法 ： SQL 92 limit MYSQL自己的语法elect * from t1 语法错误 sytnx error .. 形成正确语法树 查询优化器（Optimizer**） mysql 觉得你写的SQL 不是完美的优化什么呢？ 索引优化 索引 只使用一个 使用最优 多表关联优化 应该是小表关联大表，类似两层for循环一样 where 优化 从左到右 MySQL 找过滤力度最大的 先执行 where id=1 and sex=’男’ where sex=’男’ and id=1 explain 从右到左 Oracle 查询缓存（Cache和Buﬀer）把查询结果存起来 SQL — &gt; hash后的值 唯一 则 表示 注意：SQL hash值是优化后的sql进行hash 存储引擎（Pluggable Storage Engines）以表为单位，创建表时，指定存储引擎 creat table xxx() engine=InnoDB/Memory/MyISAM MySQL的存储引擎是针对表进行指定的。（engine=InnoDB\\myisam） 3. 存储引擎说明 存储引擎 说明 MyISAM 高速引擎，拥有较高的插入，查询速度，但不支持事务、不支持行**锁**、支持3种不同的存储格式。包括静态型、动态型和压缩型。 InnoDB 5.5版本后MySQL的默认数据库，支持事务和行级锁定，事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全，比MyISAM处理速度稍慢、支持外键（FOREIGN KEY） ISAM MyISAM的前身，MySQL5.0以后不再默认安装 MRG_MyISAM（MERGE） 将多个表联合成一个表使用，在超大规模数据存储时很有用 Memory 内存存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。只在内存上保存数据，意味着数据可能会丢失，比如临时表，就是放在内存中的 Falcon 一种新的存储引擎，支持事物处理，传言可能是InnoDB的替代者 Archive 将数据压缩后进行存储，非常适合存储大量的独立的，作为历史记录的数据，但是只能进行插入和查询操作 CSV CSV 存储引擎是基于 CSV 格式文件存储数据(应用于跨平台的数据交换) 4. InnoDB和MyISAM存储引擎区别 Innodb Myisam 存储文件 .frm 表定义文件.ibd 数据文件和索引文件 .frm 表定义文件.myd 数据文件.myi 索引文件 锁 表锁、行锁 表锁 事务 支持 不支持 CRDU 读、写 读多 count 扫表(count(1)) 专门存储的地方 （加where也扫表） 索引结构 B+ Tree B+ Tree 外键 支持 不支持 注意：从上表中可以看出，InnoDB存储引擎，数据文件和索引文件在一个文件中；而MyIsam存储的索引文件和数据文件是分开的。 5. 存储引擎的选型：InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比 较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。 MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。 MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度， 对数据的安全性要求较低，不需要持久保存，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。(比的应用如临时表) 注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎 6. 如何查看数据库默认的存储引擎查看当前数据库支持的存储引擎，使用如下命令： 1show engines; 查看数据库默认使用的存储引擎: InnoDB 1show variables like '%storage_engine%';","link":"/2019/08/02/mysql/01-mysql基础/1. 逻辑架构/"},{"title":"Go Module的简单使用","text":"Go Module的简单使用1. 打开Go Module1export GO111MODULE=on[off|auto] on 表示仅使用Go Modules模式来管理go的依赖 off 表示关闭Go Modules模式，使用GOPATH auto 表示如果在GOPATH下，就使用GOPATH；同时也可以使用GO Modules模式 2. 设置代理1export GOPROXY=https://goproxy.io 这样设置之后，可以下载google相关的包。 3. 使用1go mod init 模块名 使用上述命令，就可以初始化一个模块。","link":"/2019/08/12/Go/go module/1. 如何简单的使用go mod来进行包管理/"},{"title":"Mysql 执行流程","text":"1. 简单版本的执行流程 2. 复杂版本的执行流程","link":"/2019/08/02/mysql/01-mysql基础/2. mysql执行流程/"},{"title":"Mysql SQL执行顺序","text":"# 1. 手写sql的顺序1234567891011121314SELECT DISTINCT&lt; select_list &gt;FROM&lt; left_table &gt; &lt; join_type &gt;JOIN &lt; right_table &gt; ON &lt; join_condition &gt;WHERE&lt; where_condition &gt;GROUP BY&lt; group_by_list &gt;HAVING&lt; having_condition &gt;ORDER BY&lt; order_by_condition &gt;LIMIT &lt; limit_number &gt; 2. mysql执行的顺序1234567891011121314-- 行过滤1 FROM &lt;left_table&gt;2 ON &lt;join_condition&gt;3 &lt;join_type&gt; JOIN &lt;right_table&gt; 第二步和第三步会循环执行4 WHERE &lt;where_condition第四步会循环执行，多个条件的执行顺序是从左往右的。5 GROUP BY &lt;group_by_list&gt;6 HAVING &lt;having_condition--列过滤7 SELECT 分组之后才会执行SELECT8 DISTINCT &lt;select_list&gt;--排序9 ORDER BY &lt;order_by_condition&gt;-- MySQL附加10 LIMIT &lt;limit_number&gt; 前9步都是SQL92标准语法。limit是MySQL的独有语法。","link":"/2019/08/02/mysql/01-mysql基础/3. MySQL执行顺序/"},{"title":"Mysql中的日志","text":"# 1. 物理结构 MySQL是通过文件系统对数据和索引进行存储的。 MySQL从物理结构上可以分为日志文件和数据索引文件。 MySQL在Linux中的数据索引文件和日志文件都在/var/lib/mysql目录下。 日志文件采用顺序IO方式存储、数据文件采用随机IO方式存储。 2. 日志文件 错误日志文件 默认是开启的，而且从5.5.7以后无法关闭错误日志，错误日志记录了运行过程中遇到的所有严重的错误 信息,以及 MySQL每次启动和关闭的详细信息。位置： /var/log/mysqld.log 二进制日志（bin log） 记录数据变化，binlog记录了数据库所有的ddl语句和dml语句，但不包括select语句内容，语句以事件的形式保存，描述了数据的变更顺序，binlog还包括了每个更新语句的执行时间信息。如果是DDL语句，则直接记录到binlog日志，而DML语句，必须通过事务提交才能记录到binlog日志中。 生产中开启 主要：用于数据备份，恢复，主从复制。 如果开启呢？ 在/etc/my.cnf文件中的[mysqld] section中，进行如下配置 12# bin-loglog-bin=mysql-bin 注意： 打开之后，每重启一次mysql服务器，都会创建的一个新的mysql-bin文件 通用查询日志 什么都记录， 耗性能，生产中不开启 慢查询日志 SQL调优 定位慢的select 默认是关闭，需要通过以下方式来进行开启： 123456#开启慢查询日志slow_query_log=ON #慢查询的阈值long_query_time=3#日志记录文件如果没有给出file_name值， 默认为主机名，后缀为-slow.log。如果给出了文件名，但不是绝对路径名，文件则写入数据目录。slow_query_log_file=file_name 记录执行时间超过long_query_time秒的所有查询，便于收集查询时间比较长的SQL语句 重做日志（redo log） 回滚日志 (undo log) 中继日志 （relay log） 查看日志开启情况，使用如下命令： 1show variables like 'log_%' 查看数据文件的位置： 1show variables like '%datadir%'","link":"/2019/08/02/mysql/01-mysql基础/4. Mysql中的日志/"},{"title":"Mysql的数据文件","text":"# 1. 查看数据文件的位置1show variables like '%datadir%' 2. 数据文件 InnoDB数据文件 .frm文件： 主要存放与表相关的数据信息，主要包括表结构定义的信心 .ibd: 使用独享表空间存储表数据和索引信息，一张表对应一个ibd文件，也就是说，数据文件和索引文件在一个文件中。 ibdata文件： 使用共享表空间存储存储数据和索引信息，所有表共享使用一个或者多个ibdata文件 。 MyIsam数据文件 .frm文件：主要存放与表相关的数据信息,主要包括表结构的定义信息 .myd文件：主要用来存储表数据信息。 .myi文件：主要用来存储表数据文件中任何索引的数据树。 从上述可以看出，InnoDB的数据和索引在一个文件中，而MyIsam的数据和索引是存在不同的文件中的。","link":"/2019/08/02/mysql/01-mysql基础/5. mysql数据文件/"},{"title":"Mysql中的索引原理","text":"1. 是什么官方介绍索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度， 也就是排序好的快速查询的数据结构。 2. 索引的优势和劣势2.1 优势 可以提高数据检索的效率，降低数据库的IO成本，类似于书的目录。 – 检索 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。 –排序 被索引的列会自动进行排序，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一 些。 如果按照索引列的顺序进行排序，对应order by语句来说，效率就会提高很多。 where 索引列 在存储引擎层 处理 2.2 劣势 索引会占据磁盘空间 索引虽然会提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件。 3. 索引的分类 单列索引 组合索引 全文索引 空间索引 位图索引 oracle 4. 索引的使用4.1 创建索引 单列索引之普通索引 12CREATE INDEX index_name ON table(column(length)) ;ALTER TABLE table_name ADD INDEX index_name (column(length)) ; 单列索引之唯一索引 12CREATE UNIQUE INDEX index_name ON table(column(length)) ;alter table table_name add unique index index_name(column); 单列索引之全文索引 12CREATE FULLTEXT INDEX index_name ON table(column(length)) ; alter table table_name add fulltext index_name(column) 组合索引 1ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10)) ; 4.2 删除索引1DROP INDEX index_name ON table 4.3查看索引1SHOW INDEX FROM table_name; 5. 索引原理分析5.1 索引的存储结构索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引； MyIsam和InnoDB存储引擎： 只支持B+Tree索引，也就是说默认使用B+Tree索引，不能够更换 Memory/HEAP存储引擎： 支持HASH和BTree索引 5.2 B树和B+树B树图示B树是为了磁盘或其它存储设备而设计的一种多叉（下面你会看到，相对于二叉，B树每个内结点有多个 分支，即多叉）平衡查找树。 多叉平衡 B树的高度一般都是在2-4这个高度，树的高度直接影响IO的读写次数 如果是三层树结构—支撑的数据可以达到20G，如果是四层树结构—支撑的数据可以达到几十T B和B+的区别 B树和B+树的最大区别在于非叶子节点是否存储数据的问题。 B树是非叶子节点和叶子节点都会存储数据。 B+树只有叶子节点才会存储数据，而且存储的数据都是在一行上，而且这些数据都是有指针指向 的，也就是有顺序的。 5.3 非聚簇索引（MyISAM）对于MyISAM存储引擎，也是采用的是B+Tree索引， 由于MyISAM存储引擎，数据和索引是在不同的文件中的，因此不管是否是主键索引，B+Tree索引的叶子节点存储的是数据行的地址，不会存储行数据。 主键索引 辅助索引（次要索引） 5.4 聚簇索引（InnoDB）对于InnoDB，数据和索引是在一个文件中，InnoDB采用B+Tree索引，叶子节点上存储的是索引和数据，并非地址值。对于聚簇索引的主键索引，叶子节点存储的主键对应的一整行数据，对于非主键索引，叶子节点上存储的是主键值， 如果不是覆盖索引，那么会产生回表，降低查询速度。 对于聚集索引，表示的是数据和索引在一个文件中 主键索引 注意： 叶子节点上的数据都是排序好的，从左到右是顺序排列的 辅助索引 这里，如果对name创建单值索引，叶子节点存储的索引值，然后通过name来信息的时候，如果使用的select *那么此时mysql，会根据叶子节点的主键值，从主键索引中查找的整行的数据。 回表： 从辅助索引中查找到主键， 然后从主键索引中查找数据的过程，被称为”回表“ select * from t where name=’Alice’ 给name做了索引找两个索引树 select id,name from t where name=’Alice’ – 只查找了一次索引树，因为在辅助索引中，可以找到所有的数据。所以不需要回表** 形成索引树覆盖索引 覆盖索引，实质就是能够一次性从辅助索引树上，拿到所有的数据，不产生回表的操作。 利用组合索引 完成索引覆盖覆盖 score name 建立成一个索引","link":"/2019/08/02/mysql/01-mysql基础/6. mysql中的索引/"},{"title":"go语言提供的静态服务器","text":"go语言提供的静态服务器在go语言中，默认提供了静态的文件服务器，使用方法如下 123456789101112131415161718192021222324252627282930313233343536373839404142/** * * @Author fchunbo * @Date 2019-03-18 13:42 */package mainimport ( \"fmt\" \"log\" \"net/http\" \"os\")func sayHello(w http.ResponseWriter, r *http.Request) { r.ParseForm() // 解析参数，默认是不会解析的 fmt.Println(r.Form) fmt.Println(\"path： \", r.URL.Path) fmt.Println(\"schema: \", r.URL.Scheme) fmt.Println(r.Form[\"url_long\"]) for k, v := range r.Form { fmt.Println(\"key:\", k) fmt.Println(\"value: \", v) } // 给客户端返回结果 fmt.Fprintln(w, \"hello rob\")}func main() { http.HandleFunc(\"/\", sayHello) wd, _ := os.Getwd() http.Handle(\"/static/\", http.StripPrefix(\"/static/\", http.FileServer(http.Dir(wd)))) err := http.ListenAndServe(\":8080\", nil) if err != nil { log.Fatal(\"ListenServer:\", err) }} 注意：Go语言提供的静态文件服务器是基于绝对路径的，因此需要使用os.Getwd，来回去程序的路径。 用法： 1http.Handle(\"/static/\", http.StripPrefix(\"/static/\", http.FileServer(http.Dir(wd))))","link":"/2019/07/22/Go/package/http/go语言提供的静态服务器/"},{"title":"http包中serverHandler类型的分析","text":"http包中serverHandler类型的分析12345678910111213141516// serverHandler delegates to either the server's Handler or// DefaultServeMux and also handles \"OPTIONS *\" requests.type serverHandler struct { srv *Server}func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) { handler := sh.srv.Handler if handler == nil { handler = DefaultServeMux } if req.RequestURI == \"*\" &amp;&amp; req.Method == \"OPTIONS\" { handler = globalOptionsHandler{} } handler.ServeHTTP(rw, req)} serverHandler是一个结构体，在结构体中，只有一个字段sv *Server, 这里在实际运行的过程中，保存了最开始创建的Server实例，包好了服务端Ip端口信息，Handler信息等。 serverHandler也实现了http.Handler接口，我们看一下其ServeHTTP方法的实现： 1handler := sh.srv.Handler 这里是在获取Server实例中的Handler对象，也就是在调用http.ListenAndServe函数，传入的Handler。 123if handler == nil { handler = DefaultServeMux} 这里判断handler如果为空，就使用默认的handler，ServeMux。 1handler.ServeHTTP(rw, req) 这里就调用handler的ServeHTTP方法了，要么进入到自定义的handler中，要么进入到ServeMuxhandler中。 接下来我们，我们看一下serverHandler的使用的地方。其实serverHandler是在接收到客户端的请求后，调用Conn的serve方法中使用的。 1go c.serve(ctx) // 使用goroutines处理我们的请求 Conn的server方法如下： 12345678910111213141516171819202122232425262728293031// Serve a new connection.func (c *conn) serve(ctx context.Context) { c.remoteAddr = c.rwc.RemoteAddr().String() ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr()) defer func() { if err := recover(); err != nil &amp;&amp; err != ErrAbortHandler { const size = 64 &lt;&lt; 10 buf := make([]byte, size) buf = buf[:runtime.Stack(buf, false)] c.server.logf(\"http: panic serving %v: %v\\n%s\", c.remoteAddr, err, buf) } if !c.hijacked() { c.close() c.setState(c.rwc, StateClosed) } }() .....// 省略 // HTTP cannot have multiple simultaneous active requests.[*] // Until the server replies to this request, it can't read another, // so we might as well run the handler in this goroutine. // [*] Not strictly true: HTTP pipelining. We could let them all process // in parallel even if their responses need to be serialized. // But we're not going to implement HTTP pipelining because it // was never deployed in the wild and the answer is HTTP/2. // 内部的serverHandler结构体，获取Server对象，创建 // serverHandler实例，并调用ServerHTTP方法 serverHandler{c.server}.ServeHTTP(w, w.req) .....} 从这个代码中，可以看出，serverHandler起到了承上启下的作用，由于路由到了我们自定义的handler或ServeMux Handler中， 从而路由到我们的实现的Handler函数。","link":"/2019/04/19/Go/package/http/serverHander的分析/"},{"title":"Go Http包WebServer运行的整个流程与原理","text":"Http包WebServer运行的整个流程与原理讲解GO web server运行流程，使用如下例子来讲解。进行源码分析 123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\" \"log\" \"net/http\")func sayHello(w http.ResponseWriter, r *http.Request) { r.ParseForm() // 解析参数，默认是不会解析的 fmt.Println(r.Form) fmt.Println(\"path： \", r.URL.Path) fmt.Println(\"schema: \", r.URL.Scheme) fmt.Println(r.Form[\"url_long\"]) for k, v := range r.Form { fmt.Println(\"key:\", k) fmt.Println(\"value: \", v) } // 给客户端返回结果 fmt.Fprintln(w, \"hello rob\")}func main() { http.HandleFunc(\"/\", sayHello) err := http.ListenAndServe(\":8080\", nil) if err != nil { log.Fatal(\"ListenServer:\", err) }} 上述程序就构成了一个简单的web server，是如何运行的呢？就从main函数开始讲解。 Handler函数的注册首先注册我们handler函数 1http.HandleFunc(\"/\", sayHello) http.HandleFunc函数的源码如下： 123func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { DefaultServeMux.HandleFunc(pattern, handler)} 可以看到，http.HandleFunc函数的实质是DefaultServeMux的HandleFunc方法，那么DefaultServeMux的定义为： 1234// DefaultServeMux is the default ServeMux used by Serve.var DefaultServeMux = &amp;defaultServeMuxvar defaultServeMux ServeMux 可以看出DefaultServeMux就是ServeMUX 指针类型。ServeMux的作用就是起到了默认的路由器的作用。定义如下： 12345type ServeMux struct { mu sync.RWMutex m map[string]muxEntry hosts bool // whether any patterns contain hostnames} 其HandleFunc方法如下： 1234567891011121314151617181920212223242526272829303132333435// HandleFunc registers the handler function for the given pattern.func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { if handler == nil { panic(\"http: nil handler\") } // 这里调用了自身的Handle方法, HandlerFunc 函数类型 mux.Handle(pattern, HandlerFunc(handler))}// Handle registers the handler for the given pattern.// If a handler already exists for pattern, Handle panics.func (mux *ServeMux) Handle(pattern string, handler Handler) { mux.mu.Lock() defer mux.mu.Unlock() if pattern == \"\" { panic(\"http: invalid pattern\") } if handler == nil { panic(\"http: nil handler\") } if _, exist := mux.m[pattern]; exist { panic(\"http: multiple registrations for \" + pattern) } if mux.m == nil { mux.m = make(map[string]muxEntry) } mux.m[pattern] = muxEntry{h: handler, pattern: pattern} if pattern[0] != '/' { mux.hosts = true }} 注意：在改方法中，handler就是sayHello函数.mux.Handle(pattern, HandlerFunc(handler))中，HandlerFunc(handler) 是一个强制类型转换语句，HandlerFunc其实一个函数类型，实现了Handler接口。定义如下： 1234567type HandlerFunc func(ResponseWriter, *Request)// ServeHTTP calls f(w, r). func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) // 调用HandlerFunc类型自身。} 从源码中可以看出，HandlerFunc类型实现了http.Handler接口的ServeHTTP函数，也就说HandlerFunc也就是http.Handler类型。其中的 ServeMux的Handle方法，就实现了URI和Handler的映射。 请求是如何到达后端的处理函数说明请求是如何到达后端函数，从如下语句说起： 1err := http.ListenAndServe(\":8080\", nil) http.ListenAndServe函数，设置Web Server的端口，并监听客户端的请求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091func ListenAndServe(addr string, handler Handler) error { // 创建server，我们设置的handler为nil，相当于默认使用ServeMux去处理 server := &amp;Server{Addr: addr, Handler: handler} // 调用了Server的ListenAndServe()方法 return server.ListenAndServe()}// Server的ListenAndServe()方法的源码如下：func (srv *Server) ListenAndServe() error { if srv.shuttingDown() { return ErrServerClosed } addr := srv.Addr if addr == \"\" { addr = \":http\" } // 调用net包中的Listen函数，监听网络 ln, err := net.Listen(\"tcp\", addr) if err != nil { return err } return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})}// Server 的Serve方法的源码如下func (srv *Server) Serve(l net.Listener) error { if fn := testHookServerServe; fn != nil { fn(srv, l) // call hook with unwrapped listener } l = &amp;onceCloseListener{Listener: l} defer l.Close() if err := srv.setupHTTP2_Serve(); err != nil { return err } if !srv.trackListener(&amp;l, true) { return ErrServerClosed } defer srv.trackListener(&amp;l, false) var tempDelay time.Duration // how long to sleep on accept failure baseCtx := context.Background() // base is always background, per Issue 16220 ctx := context.WithValue(baseCtx, ServerContextKey, srv) for { rw, e := l.Accept() // 阻塞监听客户端的连接 if e != nil { select { case &lt;-srv.getDoneChan(): return ErrServerClosed default: } if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() { if tempDelay == 0 { tempDelay = 5 * time.Millisecond } else { tempDelay *= 2 } if max := 1 * time.Second; tempDelay &gt; max { tempDelay = max } srv.logf(\"http: Accept error: %v; retrying in %v\", e, tempDelay) time.Sleep(tempDelay) continue } return e } tempDelay = 0 // 这里表示，有客户端的请求进来 // 调用Server的newConn方法，获取到一个连接 c := srv.newConn(rw) c.setState(c.rwc, StateNew) // before Serve can return go c.serve(ctx) // 使用goroutines处理我们的请求 }}// Create new connection from rwc.func (srv *Server) newConn(rwc net.Conn) *conn { c := &amp;conn{ server: srv, // 将Server实例传入，初始化conn rwc: rwc, } if debugServerConnections { c.rwc = newLoggingConn(\"server\", c.rwc) } return c} 注意: c 为conn实例，代表HTTP Server端的一个连接，内部封装Server对象信息。 c.serve(ctx)语句就是处理用户请求，其源码如下： 12345678910111213141516171819202122232425262728293031// Serve a new connection.func (c *conn) serve(ctx context.Context) { c.remoteAddr = c.rwc.RemoteAddr().String() ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr()) defer func() { if err := recover(); err != nil &amp;&amp; err != ErrAbortHandler { const size = 64 &lt;&lt; 10 buf := make([]byte, size) buf = buf[:runtime.Stack(buf, false)] c.server.logf(\"http: panic serving %v: %v\\n%s\", c.remoteAddr, err, buf) } if !c.hijacked() { c.close() c.setState(c.rwc, StateClosed) } }() .....// 省略 // HTTP cannot have multiple simultaneous active requests.[*] // Until the server replies to this request, it can't read another, // so we might as well run the handler in this goroutine. // [*] Not strictly true: HTTP pipelining. We could let them all process // in parallel even if their responses need to be serialized. // But we're not going to implement HTTP pipelining because it // was never deployed in the wild and the answer is HTTP/2. // 内部的serverHandler结构体，获取Server对象，创建 // serverHandler实例，并调用ServerHTTP方法 serverHandler{c.server}.ServeHTTP(w, w.req) .....} serverHandler结构体的ServeHTTP方法如下： 123456789101112131415161718192021// serverHandler delegates to either the server's Handler or// DefaultServeMux and also handles \"OPTIONS *\" requests.type serverHandler struct { srv *Server}func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) { // 首先去获取Server的Handler，我们初始化的时候为nil，从这里可以看出 // 我们可以实现Handler来接管默认的路由器 handler := sh.srv.Handler if handler == nil { // 如果handler为nil， 就使用DefaultServeMux,也就是默认的路由器 handler = DefaultServeMux } if req.RequestURI == \"*\" &amp;&amp; req.Method == \"OPTIONS\" { handler = globalOptionsHandler{} } // 调用ServerMux的ServeHTTP方法， 实现路由 handler.ServeHTTP(rw, req)} ServerMux的ServeHTTP方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// ServeHTTP dispatches the request to the handler whose// pattern most closely matches the request URL.func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) { if r.RequestURI == \"*\" { if r.ProtoAtLeast(1, 1) { w.Header().Set(\"Connection\", \"close\") } w.WriteHeader(StatusBadRequest) return } // 根据request的URI获取对应的Handler，这里就是我们的HandlerFunc类型的handler h, _ := mux.Handler(r) h.ServeHTTP(w, r)}func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) { // CONNECT requests are not canonicalized. if r.Method == \"CONNECT\" { // If r.URL.Path is /tree and its handler is not registered, // the /tree -&gt; /tree/ redirect applies to CONNECT requests // but the path canonicalization does not. if u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok { return RedirectHandler(u.String(), StatusMovedPermanently), u.Path } return mux.handler(r.Host, r.URL.Path) } // All other requests have any port stripped and path cleaned // before passing to mux.handler. host := stripHostPort(r.Host) path := cleanPath(r.URL.Path) // If the given path is /tree and its handler is not registered, // redirect for /tree/. if u, ok := mux.redirectToPathSlash(host, path, r.URL); ok { return RedirectHandler(u.String(), StatusMovedPermanently), u.Path } if path != r.URL.Path { _, pattern = mux.handler(host, path) url := *r.URL url.Path = path return RedirectHandler(url.String(), StatusMovedPermanently), pattern } return mux.handler(host, r.URL.Path)}func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) { mux.mu.RLock() defer mux.mu.RUnlock() // Host-specific pattern takes precedence over generic ones if mux.hosts { h, pattern = mux.match(host + path) } if h == nil { h, pattern = mux.match(path) } if h == nil { h, pattern = NotFoundHandler(), \"\" } return} 当获取到HandlerFunc类型Handler时，就会调用去调用自己，HandlerFunc的ServeHTTP方法如下： 1234// ServeHTTP calls f(w, r).func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) // 调用自己，也就是我们注册的后台处理方法。在这个例子中就是调用sayhello函数} Go 代码执行流程通过对http包的分析之后，现在让我们来梳理一下整个的代码执行过程。首先调用Http.HandleFunc按顺序做了几件事： 调用了DefaultServeMux的HandleFunc 调用了DefaultServeMux的Handle 往DefaultServeMux的map[string]muxEntry中增加对应的handler和路由规则 其次调用http.ListenAndServe(“:9090”, nil)， 按顺序做了几件事情: 实例化Server 调用Server的ListenAndServe() 调用net.Listen(“tcp”, addr)监听端口 启动一个for循环，在循环体中Accept请求 对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve() 读取每个请求的内容w, err := c.readRequest() 判断handler是否为空，如果没有设置handler（ 这个例子就没有设置handler） ，handler就设置为DefaultServeMux 调用handler的ServeHttp 在这个例子中，下面就进入到DefaultServeMux.ServeHttp 根据request选择handler，并且进入到这个handler的ServeHTTP 1mux.handler(r).ServeHTTP(w, r) 选择handler：A 判断是否有路由能满足这个request（ 循环遍历ServeMux的muxEntry）B 如果有路由满足，调用这个路由handler的ServeHTTPC 如果没有路由满足，调用NotFoundHandler的ServeHTTP","link":"/2019/07/22/Go/package/http/Go http包web server的原理/"}],"tags":[{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"MySql","slug":"MySql","link":"/tags/MySql/"}],"categories":[{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"MySql","slug":"MySql","link":"/categories/MySql/"},{"name":"Basic","slug":"MySql/Basic","link":"/categories/MySql/Basic/"},{"name":"http","slug":"Go/http","link":"/categories/Go/http/"}]}